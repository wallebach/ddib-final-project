<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Subscription Platform Test</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      .section-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }
      h1,
      h2 {
        color: #333;
      }
      .status {
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        font-weight: bold;
      }
      .status.connected {
        background-color: #d4edda;
        color: #155724;
      }
      .status.disconnected {
        background-color: #f8d7da;
        color: #721c24;
      }
      button {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        margin: 5px;
      }
      button:hover {
        background-color: #0056b3;
      }
      button:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
      }
      button.danger {
        background-color: #dc3545;
      }
      button.danger:hover {
        background-color: #c82333;
      }
      button.success {
        background-color: #28a745;
      }
      button.success:hover {
        background-color: #218838;
      }
      input,
      textarea,
      select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin: 5px 0;
        box-sizing: border-box;
      }
      .creator-card,
      .subscription-card {
        border: 1px solid #ddd;
        padding: 15px;
        margin: 10px 0;
        border-radius: 5px;
        background-color: #f9f9f9;
      }
      .subscription-active {
        border-left: 4px solid #28a745;
      }
      .subscription-expired {
        border-left: 4px solid #dc3545;
      }
      .price-display {
        display: flex;
        justify-content: space-between;
        margin: 10px 0;
        font-weight: bold;
      }
      .balance-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #e9ecef;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
      }
      .error {
        color: #dc3545;
        background-color: #f8d7da;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
      }
      .success {
        color: #155724;
        background-color: #d4edda;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
      }
      .info {
        color: #0066cc;
        background-color: #e6f3ff;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
      }
      .tabs {
        display: flex;
        border-bottom: 2px solid #ddd;
        margin-bottom: 20px;
      }
      .tab {
        padding: 10px 20px;
        cursor: pointer;
        border: none;
        background: none;
        border-bottom: 2px solid transparent;
        margin: 0;
      }
      .tab.active {
        border-bottom-color: #007bff;
        color: #007bff;
        font-weight: bold;
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      .staking-info {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        padding: 15px;
        border-radius: 5px;
        margin: 10px 0;
      }
      .creator-browse-card {
        border: 1px solid #ddd;
        padding: 20px;
        margin: 15px 0;
        border-radius: 10px;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s, box-shadow 0.2s;
      }
      .creator-browse-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
      }
      .creator-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      .creator-title {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
        word-break: break-all;
      }
      .subscriber-badge {
        background-color: #007bff;
        color: white;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 0.9em;
        font-weight: bold;
      }
      .pricing-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin: 15px 0;
      }
      .price-card {
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        border: 2px solid #e9ecef;
      }
      .price-card.recommended {
        border-color: #28a745;
        background-color: #f8fff9;
      }
      .price-label {
        font-weight: bold;
        color: #666;
        margin-bottom: 5px;
      }
      .price-amount {
        font-size: 1.5em;
        font-weight: bold;
        color: #007bff;
        margin-bottom: 5px;
      }
      .price-period {
        color: #666;
        font-size: 0.9em;
      }
      .subscribe-actions {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 15px;
      }
      .subscription-status {
        background-color: #d4edda;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
        text-align: center;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>Subscription Platform Test Interface</h1>

    <div class="container">
      <h2>Connection Status</h2>
      <div id="connectionStatus" class="status disconnected">Not Connected</div>
      <button onclick="connectWallet()" id="connectBtn">
        Connect MetaMask
      </button>
      <div id="accountInfo" style="display: none">
        <p><strong>Account:</strong> <span id="accountAddress"></span></p>
        <div class="balance-info">
          <span
            ><strong>STR Balance:</strong>
            <span id="strBalance">0</span> STR</span
          >
          <span
            ><strong>GRN Balance:</strong>
            <span id="grnBalance">0</span> GRN</span
          >
          <span
            ><strong>Staked STR:</strong>
            <span id="stakedBalance">0</span> STR</span
          >
        </div>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" onclick="switchTab('creator')">
        Creator Dashboard
      </button>
      <button class="tab" onclick="switchTab('subscriber')">
        Subscriber Dashboard
      </button>
      <button class="tab" onclick="switchTab('staking')">Staking</button>
    </div>

    <div id="creatorTab" class="tab-content active">
      <div class="section-grid">
        <div class="container">
          <h2>Creator Registration</h2>
          <div id="creatorStatus"></div>
          <div id="creatorRegistrationForm">
            <input
              type="text"
              id="creatorName"
              placeholder="Your Creator Name"
              maxlength="50"
            />
            <input
              type="number"
              id="monthlyPrice"
              placeholder="Monthly Price (STR)"
              step="0.01"
            />
            <input
              type="number"
              id="yearlyPrice"
              placeholder="Yearly Price (STR)"
              step="0.01"
            />
            <button
              onclick="registerCreator()"
              id="registerCreatorBtn"
              disabled
            >
              Register as Creator
            </button>
          </div>
          <div id="creatorUpdateForm" style="display: none">
            <input
              type="number"
              id="updateMonthlyPrice"
              placeholder="New Monthly Price (STR)"
              step="0.01"
            />
            <input
              type="number"
              id="updateYearlyPrice"
              placeholder="New Yearly Price (STR)"
              step="0.01"
            />
            <button onclick="updateCreatorPrices()" class="success">
              Update Prices
            </button>
          </div>
        </div>

        <div class="container">
          <h2>Creator Earnings</h2>
          <div id="creatorEarnings">
            <div class="balance-info">
              <span
                ><strong>Total Earnings:</strong>
                <span id="totalEarnings">0</span> STR</span
              >
              <span
                ><strong>Subscribers:</strong>
                <span id="subscriberCount">0</span></span
              >
            </div>
            <button onclick="withdrawEarnings()" id="withdrawBtn" disabled>
              Withdraw Earnings
            </button>
          </div>
        </div>
      </div>

      <div class="container">
        <h2>My Subscribers</h2>
        <button onclick="loadMySubscribers()" id="loadSubscribersBtn" disabled>
          Load Subscribers
        </button>
        <div id="subscribersList"></div>
      </div>
    </div>

    <div id="subscriberTab" class="tab-content">
      <div class="container">
        <h2>Discover Creators</h2>
        <button onclick="loadAllCreators()" id="loadCreatorsBtn" disabled>
          Load All Creators
        </button>
        <div id="creatorsList"></div>
      </div>

      <div class="section-grid">
        <div class="container">
          <h2>Search Specific Creator</h2>
          <input
            type="text"
            id="creatorAddress"
            placeholder="Enter creator address"
          />
          <button onclick="loadCreatorInfo()" id="loadCreatorBtn" disabled>
            Load Creator Info
          </button>
          <div id="creatorInfo"></div>
        </div>

        <div class="container">
          <h2>Quick Subscribe</h2>
          <input
            type="text"
            id="subscribeCreatorAddress"
            placeholder="Creator address"
            readonly
          />
          <select id="subscriptionType">
            <option value="false">Monthly Subscription</option>
            <option value="true">Yearly Subscription</option>
          </select>
          <button onclick="subscribeToCreator()" id="subscribeBtn" disabled>
            Subscribe
          </button>
          <div id="subscribeResult"></div>
        </div>
      </div>

      <div class="container">
        <h2>My Subscriptions</h2>
        <button
          onclick="loadMySubscriptions()"
          id="loadSubscriptionsBtn"
          disabled
        >
          Load My Subscriptions
        </button>
        <div id="subscriptionsList"></div>
      </div>
    </div>

    <div id="stakingTab" class="tab-content">
      <div class="container">
        <h2>STR Staking</h2>
        <div class="staking-info">
          <h3>Staking Information</h3>
          <p>
            <strong>Your Staked Amount:</strong>
            <span id="stakedAmount">0</span> STR
          </p>
          <p>
            <strong>Pending GRN Rewards:</strong>
            <span id="pendingRewards">0</span> GRN
            <button
              onclick="loadPendingRewards()"
              style="margin-left: 10px; padding: 5px 10px; font-size: 0.8em"
            >
              üîÑ Load Rewards
            </button>
          </p>
        </div>

        <div class="section-grid">
          <div>
            <h3>Stake STR</h3>
            <input
              type="number"
              id="stakeAmount"
              placeholder="Amount to stake (STR)"
              step="0.01"
            />
            <button onclick="stakeSTR()" id="stakeBtn" disabled>
              Stake STR
            </button>
          </div>

          <div>
            <h3>Unstake STR</h3>
            <input
              type="number"
              id="unstakeAmount"
              placeholder="Amount to unstake (STR)"
              step="0.01"
            />
            <button
              onclick="unstakeSTR()"
              id="unstakeBtn"
              disabled
              class="danger"
            >
              Unstake STR
            </button>
          </div>
        </div>

        <button
          onclick="claimGRNRewards()"
          id="claimBtn"
          disabled
          class="success"
        >
          Claim GRN Rewards
        </button>
        <div id="stakingResult"></div>
      </div>
    </div>

    <script>
      const SUBSCRIPTION_ADDRESS = "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0"
      const STR_TOKEN_ADDRESS = "0x5FbDB2315678afecb367f032d93F642f64180aa3"
      const GRN_TOKEN_ADDRESS = "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"

      const SUBSCRIPTION_ABI = [
        "function registerCreator(string memory _name, uint256 _monthlyPrice, uint256 _yearlyPrice) external",
        "function updateCreatorPrices(uint256 _monthlyPrice, uint256 _yearlyPrice) external",
        "function subscribeToCreator(address creator, bool isYearly) external",
        "function stakeSTR(uint256 amount) external",
        "function unstakeSTR(uint256 amount) external",
        "function claimGRNRewards() external",
        "function withdrawCreatorEarnings() external",
        "function isSubscriptionActive(address subscriber, address creator) external view returns (bool)",
        "function getCreatorInfo(address creator) external view returns (bool, string, uint256, uint256, uint256, uint256)",
        "function getUserSubscribedCreators(address user) external view returns (address[])",
        "function getCreatorSubscribers(address creator) external view returns (address[])",
        "function calculateGRNReward(address user) external view returns (uint256)",
        "function creators(address) external view returns (bool, string, uint256, uint256, uint256, uint256)",
        "function subscriptions(address, address) external view returns (uint256, bool, bool)",
        "function stakedSTR(address) external view returns (uint256)",
        "function stakingTimestamp(address) external view returns (uint256)",
        "event SubscriptionPurchased(address indexed subscriber, address indexed creator, uint256 amount, uint256 expiration, bool isYearly)",
        "event CreatorRegistered(address indexed creator, string name, uint256 monthlyPrice, uint256 yearlyPrice)",
        "event STRStaked(address indexed user, uint256 amount)",
        "event STRUnstaked(address indexed user, uint256 amount)",
        "event GRNRewardClaimed(address indexed user, uint256 amount)",
      ]

      const TOKEN_ABI = [
        "function balanceOf(address owner) view returns (uint256)",
        "function decimals() view returns (uint8)",
        "function approve(address spender, uint256 amount) returns (bool)",
        "function allowance(address owner, address spender) view returns (uint256)",
      ]

      let provider
      let signer
      let subscriptionContract
      let strTokenContract
      let grnTokenContract
      let userAccount
      let allCreators = []
      let creatorsLoaded = false
      let stakingRefreshInterval

      async function connectWallet() {
        try {
          if (!window.ethereum) {
            throw new Error("MetaMask not found!")
          }

          provider = new ethers.providers.Web3Provider(window.ethereum)
          await provider.send("eth_requestAccounts", [])
          signer = provider.getSigner()
          userAccount = await signer.getAddress()

          subscriptionContract = new ethers.Contract(
            SUBSCRIPTION_ADDRESS,
            SUBSCRIPTION_ABI,
            signer
          )
          strTokenContract = new ethers.Contract(
            STR_TOKEN_ADDRESS,
            TOKEN_ABI,
            signer
          )
          grnTokenContract = new ethers.Contract(
            GRN_TOKEN_ADDRESS,
            TOKEN_ABI,
            provider
          )

          document.getElementById("connectionStatus").textContent = "Connected"
          document.getElementById("connectionStatus").className =
            "status connected"
          document.getElementById("accountAddress").textContent = userAccount
          document.getElementById("accountInfo").style.display = "block"
          document.getElementById("connectBtn").disabled = true

          enableAllButtons()

          await updateBalances()
          await loadCreatorStatus()
          await loadStakingInfo()

          startStakingRefresh()

          if (creatorsLoaded && allCreators.length > 0) {
            await refreshCreatorSubscriptionStatus()
          }

          showSuccess("Successfully connected to MetaMask!", "subscribeResult")
        } catch (error) {
          showError(
            "Failed to connect wallet: " + error.message,
            "subscribeResult"
          )
        }
      }

      function enableAllButtons() {
        const buttons = [
          "registerCreatorBtn",
          "loadCreatorBtn",
          "subscribeBtn",
          "loadSubscriptionsBtn",
          "loadSubscribersBtn",
          "withdrawBtn",
          "stakeBtn",
          "unstakeBtn",
          "claimBtn",
          "loadCreatorsBtn",
        ]
        buttons.forEach((id) => {
          const btn = document.getElementById(id)
          if (btn) btn.disabled = false
        })
      }

      async function updateBalances() {
        try {
          const [strBalance, grnBalance, stakedBalance] = await Promise.all([
            strTokenContract.balanceOf(userAccount),
            grnTokenContract.balanceOf(userAccount),
            subscriptionContract.stakedSTR(userAccount),
          ])

          document.getElementById("strBalance").textContent =
            ethers.utils.formatEther(strBalance)
          document.getElementById("grnBalance").textContent =
            ethers.utils.formatEther(grnBalance)
          document.getElementById("stakedBalance").textContent =
            ethers.utils.formatEther(stakedBalance)
          document.getElementById("stakedAmount").textContent =
            ethers.utils.formatEther(stakedBalance)
        } catch (error) {
          console.error("Failed to update balances:", error)
        }
      }

      async function loadCreatorStatus() {
        try {
          const creatorInfo = await subscriptionContract.creators(userAccount)
          const isRegistered = creatorInfo[0]

          if (isRegistered) {
            const creatorName = creatorInfo[1]
            const monthlyPrice = ethers.utils.formatEther(creatorInfo[2])
            const yearlyPrice = ethers.utils.formatEther(creatorInfo[3])
            const totalEarnings = ethers.utils.formatEther(creatorInfo[4])
            const subscriberCount = creatorInfo[5].toString()

            document.getElementById("creatorStatus").innerHTML = `
                        <div class="success">You are registered as creator: <strong>${creatorName}</strong></div>
                        <div class="price-display">
                            <span>Monthly: ${monthlyPrice} STR</span>
                            <span>Yearly: ${yearlyPrice} STR</span>
                        </div>
                    `
            document.getElementById("creatorRegistrationForm").style.display =
              "none"
            document.getElementById("creatorUpdateForm").style.display = "block"
            document.getElementById("totalEarnings").textContent = totalEarnings
            document.getElementById("subscriberCount").textContent =
              subscriberCount

            document.getElementById("updateMonthlyPrice").value = monthlyPrice
            document.getElementById("updateYearlyPrice").value = yearlyPrice
          } else {
            document.getElementById("creatorStatus").innerHTML = `
                        <div class="info">You are not registered as a creator yet.</div>
                    `
          }
        } catch (error) {
          console.error("Failed to load creator status:", error)
        }
      }

      async function loadStakingInfo() {
        console.log("üîç Starting loadStakingInfo...")

        if (!userAccount || !subscriptionContract) {
          console.log("‚ùå Missing userAccount or subscriptionContract")
          return
        }

        try {
          console.log("‚úÖ Connected, fetching data for:", userAccount)

          console.log("Getting staked amount...")
          const stakedAmount = await subscriptionContract.stakedSTR(userAccount)
          console.log(
            "‚úÖ Got staked amount:",
            ethers.utils.formatEther(stakedAmount)
          )

          console.log("Getting staking timestamp...")
          const stakingTimestamp = await subscriptionContract.stakingTimestamp(
            userAccount
          )
          console.log("‚úÖ Got staking timestamp:", stakingTimestamp.toString())

          console.log("Getting current block...")
          const currentBlock = await provider.getBlock("latest")
          console.log(
            "‚úÖ Got current block:",
            currentBlock.number,
            "timestamp:",
            currentBlock.timestamp
          )

          console.log("Getting pending rewards...")
          const pendingRewards = await subscriptionContract.calculateGRNReward(
            userAccount
          )
          console.log(
            "‚úÖ Got pending rewards:",
            ethers.utils.formatEther(pendingRewards)
          )

          const stakingTime = stakingTimestamp.toNumber()
          const blockTimestamp = currentBlock.timestamp
          const stakingDuration =
            stakingTime > 0 ? blockTimestamp - stakingTime : 0

          console.log("üìä Calculation results:")
          console.log("  - Staked STR:", ethers.utils.formatEther(stakedAmount))
          console.log("  - Staking timestamp:", stakingTime)
          console.log("  - Block timestamp:", blockTimestamp)
          console.log("  - Duration:", stakingDuration, "seconds")
          console.log(
            "  - Pending rewards:",
            ethers.utils.formatEther(pendingRewards)
          )

          console.log("Updating UI elements...")
          document.getElementById("stakedAmount").textContent =
            ethers.utils.formatEther(stakedAmount)
          document.getElementById("pendingRewards").textContent =
            ethers.utils.formatEther(pendingRewards)

          console.log("‚úÖ loadStakingInfo completed successfully")
        } catch (error) {
          console.error("‚ùå Failed to load staking info:", error)
          console.error("Error details:", error.message)
          console.error("Error stack:", error.stack)
        }
      }

      window.testRewardsDirectly = async function () {
        try {
          console.log("üß™ Direct contract testing...")

          const stakedAmount = await subscriptionContract.stakedSTR(userAccount)
          const stakingTimestamp = await subscriptionContract.stakingTimestamp(
            userAccount
          )
          const pendingRewards = await subscriptionContract.calculateGRNReward(
            userAccount
          )
          const currentBlock = await provider.getBlock("latest")

          console.log("üîç Raw contract data:")
          console.log("  - Staked STR (wei):", stakedAmount.toString())
          console.log("  - Staking timestamp:", stakingTimestamp.toString())
          console.log("  - Block timestamp:", currentBlock.timestamp)
          console.log(
            "  - Duration:",
            currentBlock.timestamp - stakingTimestamp.toNumber()
          )
          console.log("  - Pending rewards (wei):", pendingRewards.toString())
          console.log(
            "  - Pending rewards (ether):",
            ethers.utils.formatEther(pendingRewards)
          )

          return {
            stakedAmount: stakedAmount.toString(),
            stakingTimestamp: stakingTimestamp.toString(),
            blockTimestamp: currentBlock.timestamp,
            pendingRewards: pendingRewards.toString(),
            formattedRewards: ethers.utils.formatEther(pendingRewards),
          }
        } catch (error) {
          console.error("Direct test failed:", error)
          return error
        }
      }

      async function loadPendingRewards() {
        console.log(
          "üîÑ Making transaction to update blockchain and load pending rewards..."
        )

        if (!userAccount || !subscriptionContract) {
          console.log("‚ùå Not connected to wallet or contract")
          alert("Please connect your wallet first")
          return
        }

        try {
          const button = document.querySelector(
            'button[onclick="loadPendingRewards()"]'
          )
          if (button) {
            button.textContent = "‚è≥ Loading..."
            button.disabled = true
          }

          console.log(
            "üì° Making a small transaction to update blockchain timestamp..."
          )

          const currentAllowance = await strTokenContract.allowance(
            userAccount,
            SUBSCRIPTION_ADDRESS
          )
          console.log(
            "Current STR allowance:",
            ethers.utils.formatEther(currentAllowance)
          )

          const tx = await strTokenContract.approve(
            SUBSCRIPTION_ADDRESS,
            currentAllowance
          )
          console.log("üîó Transaction sent:", tx.hash)
          console.log("‚è≥ Waiting for transaction confirmation...")

          const receipt = await tx.wait()
          console.log("‚úÖ Transaction confirmed in block:", receipt.blockNumber)

          console.log("üìä Getting updated staking data...")
          const newBlock = await provider.getBlock("latest")
          console.log(
            "‚úÖ New block:",
            newBlock.number,
            "timestamp:",
            newBlock.timestamp
          )

          const [stakedAmount, stakingTimestamp, pendingRewards] =
            await Promise.all([
              subscriptionContract.stakedSTR(userAccount),
              subscriptionContract.stakingTimestamp(userAccount),
              subscriptionContract.calculateGRNReward(userAccount),
            ])

          console.log(
            "‚úÖ Staked amount:",
            ethers.utils.formatEther(stakedAmount),
            "STR"
          )
          console.log("‚úÖ Staking timestamp:", stakingTimestamp.toString())
          console.log("‚úÖ Raw pending rewards:", pendingRewards.toString())
          console.log(
            "‚úÖ Formatted pending rewards:",
            ethers.utils.formatEther(pendingRewards),
            "GRN"
          )

          const stakingTime = stakingTimestamp.toNumber()
          const blockTimestamp = newBlock.timestamp
          const stakingDuration =
            stakingTime > 0 ? blockTimestamp - stakingTime : 0

          console.log("üßÆ Verification calculations:")
          console.log("  - Staking duration:", stakingDuration, "seconds")
          console.log(
            "  - Expected rate: 100% per minute =",
            (100 / 60).toFixed(3),
            "% per second"
          )

          if (stakingDuration > 0 && stakedAmount.gt(0)) {
            const stakedSTRAmount = parseFloat(
              ethers.utils.formatEther(stakedAmount)
            )
            const expectedReward =
              (stakedSTRAmount * 1.0 * stakingDuration) / 60
            console.log(
              "  - Manual calculation:",
              expectedReward.toFixed(6),
              "GRN"
            )
            console.log(
              "  - Contract calculation:",
              ethers.utils.formatEther(pendingRewards),
              "GRN"
            )

            if (
              Math.abs(
                expectedReward -
                  parseFloat(ethers.utils.formatEther(pendingRewards))
              ) < 0.000001
            ) {
              console.log("‚úÖ Calculations match!")
            } else {
              console.log("‚ö†Ô∏è  Calculation mismatch detected")
            }
          }

          document.getElementById("pendingRewards").textContent =
            ethers.utils.formatEther(pendingRewards)

          console.log(
            "üéâ Transaction completed! Pending rewards:",
            ethers.utils.formatEther(pendingRewards),
            "GRN"
          )

          if (button) {
            button.textContent = "‚úÖ Updated!"
            button.style.backgroundColor = "#28a745"
            button.disabled = false

            setTimeout(() => {
              button.textContent = "üîÑ Load Rewards"
              button.style.backgroundColor = ""
            }, 3000)
          }
        } catch (error) {
          console.error("‚ùå Failed to load pending rewards:", error)
          alert("Failed to load rewards: " + error.message)

          const button = document.querySelector(
            'button[onclick="loadPendingRewards()"]'
          )
          if (button) {
            button.textContent = "üîÑ Load Rewards"
            button.disabled = false
            button.style.backgroundColor = ""
          }
        }
      }

      async function forceUpdate() {
        console.log("‚ö° Force updating blockchain state...")

        if (!userAccount || !subscriptionContract) {
          console.log("‚ùå Not connected to wallet or contract")
          return
        }

        try {
          console.log("üìä Refreshing staking data...")
          await loadStakingInfo()
          console.log("‚úÖ Force update completed")
        } catch (error) {
          console.error("‚ùå Force update failed:", error)
        }
      }

      function startStakingRefresh() {
        if (stakingRefreshInterval) {
          clearInterval(stakingRefreshInterval)
        }

        stakingRefreshInterval = setInterval(async () => {
          if (userAccount && subscriptionContract) {
            await loadStakingInfo()
          }
        }, 5000)
      }

      async function refreshRewards() {
        console.log("üîÑ Manual reward refresh requested")

        if (!userAccount || !subscriptionContract) {
          console.log("‚ùå Not connected to wallet or contract")
          return
        }

        try {
          const currentBlockNumber = await provider.getBlockNumber()
          const currentBlock = await provider.getBlock(currentBlockNumber)
          const blockTimestamp = currentBlock.timestamp

          console.log("üîó Blockchain data:")
          console.log("  - Current block:", currentBlockNumber)
          console.log(
            "  - Block timestamp:",
            blockTimestamp,
            new Date(blockTimestamp * 1000).toLocaleTimeString()
          )

          const [stakedAmount, stakingTimestamp, pendingRewards] =
            await Promise.all([
              subscriptionContract.stakedSTR(userAccount),
              subscriptionContract.stakingTimestamp(userAccount),
              subscriptionContract.calculateGRNReward(userAccount),
            ])

          const stakingTime = stakingTimestamp.toNumber()
          const stakingDuration =
            stakingTime > 0 ? blockTimestamp - stakingTime : 0

          console.log("üí∞ Fresh reward data:")
          console.log(
            "  - Staked amount:",
            ethers.utils.formatEther(stakedAmount),
            "STR"
          )
          console.log(
            "  - Staking timestamp:",
            stakingTime,
            new Date(stakingTime * 1000).toLocaleTimeString()
          )
          console.log("  - Duration:", stakingDuration, "seconds")
          console.log("  - Raw rewards:", pendingRewards.toString())
          console.log(
            "  - Formatted rewards:",
            ethers.utils.formatEther(pendingRewards),
            "GRN"
          )

          document.getElementById("pendingRewards").textContent =
            ethers.utils.formatEther(pendingRewards)

          console.log("‚úÖ Rewards updated successfully!")
        } catch (error) {
          console.error("‚ùå Failed to refresh rewards:", error)
        }
      }

      async function registerCreator() {
        try {
          const creatorName = document
            .getElementById("creatorName")
            .value.trim()
          const monthlyPrice = document.getElementById("monthlyPrice").value
          const yearlyPrice = document.getElementById("yearlyPrice").value

          if (!creatorName) {
            throw new Error("Please enter your creator name")
          }
          if (!monthlyPrice || !yearlyPrice) {
            throw new Error("Please enter both monthly and yearly prices")
          }

          const monthlyPriceWei = ethers.utils.parseEther(monthlyPrice)
          const yearlyPriceWei = ethers.utils.parseEther(yearlyPrice)

          showInfo("Registering as creator...", "creatorStatus")
          const tx = await subscriptionContract.registerCreator(
            creatorName,
            monthlyPriceWei,
            yearlyPriceWei
          )
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "creatorStatus"
          )

          await tx.wait()
          showSuccess("Successfully registered as creator!", "creatorStatus")

          await loadCreatorStatus()
          document.getElementById("creatorName").value = ""
          document.getElementById("monthlyPrice").value = ""
          document.getElementById("yearlyPrice").value = ""
        } catch (error) {
          showError(
            "Failed to register as creator: " + getErrorMessage(error),
            "creatorStatus"
          )
        }
      }

      async function updateCreatorPrices() {
        try {
          const monthlyPrice =
            document.getElementById("updateMonthlyPrice").value
          const yearlyPrice = document.getElementById("updateYearlyPrice").value

          if (!monthlyPrice || !yearlyPrice) {
            throw new Error("Please enter both monthly and yearly prices")
          }

          const monthlyPriceWei = ethers.utils.parseEther(monthlyPrice)
          const yearlyPriceWei = ethers.utils.parseEther(yearlyPrice)

          showInfo("Updating prices...", "creatorStatus")
          const tx = await subscriptionContract.updateCreatorPrices(
            monthlyPriceWei,
            yearlyPriceWei
          )
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "creatorStatus"
          )

          await tx.wait()
          showSuccess("Prices updated successfully!", "creatorStatus")

          await loadCreatorStatus()
        } catch (error) {
          showError(
            "Failed to update prices: " + getErrorMessage(error),
            "creatorStatus"
          )
        }
      }

      async function loadAllCreators() {
        try {
          showInfo("Loading all creators...", "creatorsList")

          const currentBlock = await provider.getBlockNumber()
          console.log("Current block:", currentBlock)

          const filter = subscriptionContract.filters.CreatorRegistered()
          const events = await subscriptionContract.queryFilter(
            filter,
            Math.max(0, currentBlock - 1000),
            "latest"
          )

          console.log("Found creator events:", events.length)

          if (events.length === 0) {
            document.getElementById("creatorsList").innerHTML = `
                        <div class="info">
                            <p>No creators found on the platform yet.</p>
                            <p>Be the first to register as a creator in the "Creator Dashboard" tab!</p>
                        </div>
                    `
            return
          }

          const creatorAddresses = [
            ...new Set(events.map((event) => event.args.creator)),
          ]
          allCreators = []

          console.log(
            "Checking registration status for creators:",
            creatorAddresses
          )

          let html = ""
          for (const creatorAddress of creatorAddresses) {
            try {
              console.log(`Checking creator: ${creatorAddress}`)

              const creatorInfo = await subscriptionContract.getCreatorInfo(
                creatorAddress
              )
              const isRegistered = creatorInfo[0]

              console.log(`Creator ${creatorAddress} registered:`, isRegistered)

              if (!isRegistered) {
                console.log(`Skipping unregistered creator: ${creatorAddress}`)
                continue
              }

              const [isSubscribed, subscription] = await Promise.all([
                subscriptionContract.isSubscriptionActive(
                  userAccount,
                  creatorAddress
                ),
                subscriptionContract.subscriptions(userAccount, creatorAddress),
              ])

              const creatorName = creatorInfo[1]
              const monthlyPrice = ethers.utils.formatEther(creatorInfo[2])
              const yearlyPrice = ethers.utils.formatEther(creatorInfo[3])
              const subscriberCount = creatorInfo[5].toString()

              const monthlyCost = parseFloat(monthlyPrice) * 12
              const yearlyCost = parseFloat(yearlyPrice)
              const savings = (
                ((monthlyCost - yearlyCost) / monthlyCost) *
                100
              ).toFixed(1)

              const creatorData = {
                address: creatorAddress,
                name: creatorName,
                monthlyPrice,
                yearlyPrice,
                subscriberCount,
                isSubscribed,
              }
              allCreators.push(creatorData)

              let subscriptionStatusHtml = ""
              if (isSubscribed) {
                const expirationTime = new Date(
                  subscription[0].toNumber() * 1000
                )
                const isYearly = subscription[2]
                subscriptionStatusHtml = `
                                <div class="subscription-status">
                                    ‚úÖ Active ${
                                      isYearly ? "Yearly" : "Monthly"
                                    } Subscription
                                    <br>Expires: ${expirationTime.toLocaleDateString()}
                                </div>
                            `
              }

              html += `
                            <div class="creator-browse-card">
                                <div class="creator-header">
                                    <div class="creator-title">${creatorName}</div>
                                    <div class="subscriber-badge">${subscriberCount} subscribers</div>
                                </div>
                                <div style="color: #666; font-size: 0.9em; margin-bottom: 10px;">${creatorAddress}</div>
                                
                                <div class="pricing-section">
                                    <div class="price-card">
                                        <div class="price-label">Monthly Plan</div>
                                        <div class="price-amount">${monthlyPrice} STR</div>
                                        <div class="price-period">per month</div>
                                    </div>
                                    <div class="price-card recommended">
                                        <div class="price-label">Yearly Plan</div>
                                        <div class="price-amount">${yearlyPrice} STR</div>
                                        <div class="price-period">per year</div>
                                        <div style="color: #28a745; font-weight: bold; margin-top: 5px;">
                                            Save ${savings}%
                                        </div>
                                    </div>
                                </div>
                                
                                ${
                                  !isSubscribed
                                    ? `
                                    <div class="subscribe-actions">
                                        <button onclick="selectCreator('${creatorAddress}', false)" class="success">
                                            Subscribe Monthly
                                        </button>
                                        <button onclick="selectCreator('${creatorAddress}', true)" class="success">
                                            Subscribe Yearly
                                        </button>
                                    </div>
                                `
                                    : subscriptionStatusHtml
                                }
                            </div>
                        `
            } catch (error) {
              console.error(`Failed to load creator ${creatorAddress}:`, error)
            }
          }

          if (html) {
            document.getElementById("creatorsList").innerHTML = html
            console.log(
              `Successfully loaded ${allCreators.length} registered creators`
            )
          } else {
            document.getElementById("creatorsList").innerHTML = `
                        <div class="info">
                            <p>No currently registered creators found.</p>
                            <p><strong>Found ${creatorAddresses.length} creator registration events, but none are currently active.</strong></p>
                            <p>Creators may have been registered in the past but are no longer active in the smart contract.</p>
                        </div>
                    `
          }
          creatorsLoaded = true
        } catch (error) {
          console.error("Error loading creators:", error)
          showError(
            "Failed to load creators: " + getErrorMessage(error),
            "creatorsList"
          )

          document.getElementById("creatorsList").innerHTML += `
                    <div style="margin-top: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">
                        <h4>Debugging Information:</h4>
                        <p><strong>Contract Address:</strong> ${SUBSCRIPTION_ADDRESS}</p>
                        <p><strong>User Account:</strong> ${userAccount}</p>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p><em>Make sure you're connected to the correct network (localhost:8545)</em></p>
                    </div>
                `
        }
      }

      async function refreshCreatorSubscriptionStatus() {
        try {
          if (!userAccount || allCreators.length === 0) return

          console.log(
            "Refreshing subscription status for",
            allCreators.length,
            "creators"
          )

          let html = ""
          for (const creatorData of allCreators) {
            try {
              const [isSubscribed, subscription] = await Promise.all([
                subscriptionContract.isSubscriptionActive(
                  userAccount,
                  creatorData.address
                ),
                subscriptionContract.subscriptions(
                  userAccount,
                  creatorData.address
                ),
              ])

              const monthlyCost = parseFloat(creatorData.monthlyPrice) * 12
              const yearlyCost = parseFloat(creatorData.yearlyPrice)
              const savings = (
                ((monthlyCost - yearlyCost) / monthlyCost) *
                100
              ).toFixed(1)

              let subscriptionStatusHtml = ""
              if (isSubscribed) {
                const expirationTime = new Date(
                  subscription[0].toNumber() * 1000
                )
                const isYearly = subscription[2]
                subscriptionStatusHtml = `
                                <div class="subscription-status">
                                    ‚úÖ Active ${
                                      isYearly ? "Yearly" : "Monthly"
                                    } Subscription
                                    <br>Expires: ${expirationTime.toLocaleDateString()}
                                </div>
                            `
              }

              html += `
                            <div class="creator-browse-card">
                                <div class="creator-header">
                                    <div class="creator-title">${
                                      creatorData.name
                                    }</div>
                                    <div class="subscriber-badge">${
                                      creatorData.subscriberCount
                                    } subscribers</div>
                                </div>
                                <div style="color: #666; font-size: 0.9em; margin-bottom: 10px;">${
                                  creatorData.address
                                }</div>
                                
                                <div class="pricing-section">
                                    <div class="price-card">
                                        <div class="price-label">Monthly Plan</div>
                                        <div class="price-amount">${
                                          creatorData.monthlyPrice
                                        } STR</div>
                                        <div class="price-period">per month</div>
                                    </div>
                                    <div class="price-card recommended">
                                        <div class="price-label">Yearly Plan</div>
                                        <div class="price-amount">${
                                          creatorData.yearlyPrice
                                        } STR</div>
                                        <div class="price-period">per year</div>
                                        <div style="color: #28a745; font-weight: bold; margin-top: 5px;">
                                            Save ${savings}%
                                        </div>
                                    </div>
                                </div>
                                
                                ${
                                  !isSubscribed
                                    ? `
                                    <div class="subscribe-actions">
                                        <button onclick="selectCreator('${creatorData.address}', false)" class="success">
                                            Subscribe Monthly
                                        </button>
                                        <button onclick="selectCreator('${creatorData.address}', true)" class="success">
                                            Subscribe Yearly
                                        </button>
                                    </div>
                                `
                                    : subscriptionStatusHtml
                                }
                            </div>
                        `
            } catch (error) {
              console.error(
                `Failed to refresh creator ${creatorData.address}:`,
                error
              )
            }
          }

          document.getElementById("creatorsList").innerHTML = html
        } catch (error) {
          console.error("Error refreshing creator subscription status:", error)
        }
      }

      function selectCreator(creatorAddress, isYearly) {
        document.getElementById("subscribeCreatorAddress").value =
          creatorAddress
        document.getElementById("subscriptionType").value = isYearly.toString()

        document.getElementById("subscribeCreatorAddress").scrollIntoView({
          behavior: "smooth",
          block: "center",
        })

        const container = document
          .getElementById("subscribeCreatorAddress")
          .closest(".container")
        container.style.border = "3px solid #007bff"
        setTimeout(() => {
          container.style.border = ""
        }, 2000)

        showInfo(
          `Selected creator for ${
            isYearly ? "yearly" : "monthly"
          } subscription. Click Subscribe below to proceed.`,
          "subscribeResult"
        )
      }

      async function loadCreatorInfo() {
        try {
          const address = document.getElementById("creatorAddress").value.trim()
          if (!ethers.utils.isAddress(address)) {
            throw new Error("Please enter a valid address")
          }

          const creatorInfo = await subscriptionContract.getCreatorInfo(address)

          if (!creatorInfo[0]) {
            document.getElementById("creatorInfo").innerHTML = `
                        <div class="error">Creator not found or not registered</div>
                    `
            return
          }

          const creatorName = creatorInfo[1]
          const monthlyPrice = ethers.utils.formatEther(creatorInfo[2])
          const yearlyPrice = ethers.utils.formatEther(creatorInfo[3])
          const subscriberCount = creatorInfo[5].toString()

          document.getElementById("creatorInfo").innerHTML = `
                    <div class="creator-card">
                        <h3>${creatorName}</h3>
                        <p style="color: #666; font-size: 0.9em;">${address}</p>
                        <div class="price-display">
                            <span>Monthly: ${monthlyPrice} STR</span>
                            <span>Yearly: ${yearlyPrice} STR</span>
                        </div>
                        <p><strong>Subscribers:</strong> ${subscriberCount}</p>
                        <button onclick="selectCreator('${address}', false)" class="success">Select for Monthly</button>
                        <button onclick="selectCreator('${address}', true)" class="success">Select for Yearly</button>
                    </div>
                `
        } catch (error) {
          showError(
            "Failed to load creator info: " + getErrorMessage(error),
            "creatorInfo"
          )
        }
      }

      async function subscribeToCreator() {
        try {
          const creatorAddress = document
            .getElementById("subscribeCreatorAddress")
            .value.trim()
          const isYearly =
            document.getElementById("subscriptionType").value === "true"

          if (!ethers.utils.isAddress(creatorAddress)) {
            throw new Error("Please enter a valid creator address")
          }

          const creatorInfo = await subscriptionContract.getCreatorInfo(
            creatorAddress
          )
          if (!creatorInfo[0]) {
            throw new Error("Creator not found or not registered")
          }

          const price = isYearly ? creatorInfo[3] : creatorInfo[2]
          const priceFormatted = ethers.utils.formatEther(price)

          const allowance = await strTokenContract.allowance(
            userAccount,
            SUBSCRIPTION_ADDRESS
          )
          if (allowance.lt(price)) {
            showInfo("Approving STR spending...", "subscribeResult")
            const approveTx = await strTokenContract.approve(
              SUBSCRIPTION_ADDRESS,
              ethers.constants.MaxUint256
            )
            await approveTx.wait()
          }

          showInfo(
            `Subscribing to creator (${priceFormatted} STR)...`,
            "subscribeResult"
          )
          const tx = await subscriptionContract.subscribeToCreator(
            creatorAddress,
            isYearly
          )
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "subscribeResult"
          )

          await tx.wait()
          showSuccess(
            `Successfully subscribed for ${priceFormatted} STR!`,
            "subscribeResult"
          )

          await updateBalances()
          await loadMySubscriptions()

          if (allCreators.length > 0) {
            await loadAllCreators()
          }
        } catch (error) {
          showError(
            "Failed to subscribe: " + getErrorMessage(error),
            "subscribeResult"
          )
        }
      }

      async function loadMySubscriptions() {
        try {
          const subscribedCreators =
            await subscriptionContract.getUserSubscribedCreators(userAccount)
          const subscriptionsList = document.getElementById("subscriptionsList")

          if (subscribedCreators.length === 0) {
            subscriptionsList.innerHTML = "<p>No subscriptions found.</p>"
            return
          }

          let html = ""
          for (const creatorAddress of subscribedCreators) {
            try {
              const [subscription, creatorInfo] = await Promise.all([
                subscriptionContract.subscriptions(userAccount, creatorAddress),
                subscriptionContract.getCreatorInfo(creatorAddress),
              ])

              const expirationTime = new Date(subscription[0].toNumber() * 1000)
              const isActive = subscription[1] && expirationTime > new Date()
              const isYearly = subscription[2]

              const creatorName = creatorInfo[1]
              const monthlyPrice = ethers.utils.formatEther(creatorInfo[2])
              const yearlyPrice = ethers.utils.formatEther(creatorInfo[3])

              html += `
                            <div class="subscription-card ${
                              isActive
                                ? "subscription-active"
                                : "subscription-expired"
                            }">
                                <h3>${creatorName}</h3>
                                <p style="color: #666; font-size: 0.9em;">${creatorAddress}</p>
                                <p><strong>Type:</strong> ${
                                  isYearly ? "Yearly" : "Monthly"
                                }</p>
                                <p><strong>Status:</strong> ${
                                  isActive ? "‚úÖ Active" : "‚ùå Expired"
                                }</p>
                                <p><strong>Expires:</strong> ${expirationTime.toLocaleString()}</p>
                                <div class="price-display">
                                    <span>Monthly: ${monthlyPrice} STR</span>
                                    <span>Yearly: ${yearlyPrice} STR</span>
                                </div>
                                ${
                                  !isActive
                                    ? `<button onclick="renewSubscription('${creatorAddress}')" class="success">Renew Subscription</button>`
                                    : ""
                                }
                            </div>
                        `
            } catch (error) {
              console.error(
                `Failed to load subscription for ${creatorAddress}:`,
                error
              )
            }
          }

          subscriptionsList.innerHTML = html
        } catch (error) {
          showError(
            "Failed to load subscriptions: " + getErrorMessage(error),
            "subscriptionsList"
          )
        }
      }

      async function renewSubscription(creatorAddress) {
        document.getElementById("subscribeCreatorAddress").value =
          creatorAddress
        switchTab("subscriber")
        showInfo(
          "Creator address filled. Please select subscription type and click Subscribe.",
          "subscribeResult"
        )
      }

      async function loadMySubscribers() {
        try {
          const subscribers = await subscriptionContract.getCreatorSubscribers(
            userAccount
          )
          const subscribersList = document.getElementById("subscribersList")

          if (subscribers.length === 0) {
            subscribersList.innerHTML = "<p>No subscribers found.</p>"
            return
          }

          let html = ""
          for (const subscriberAddress of subscribers) {
            try {
              const subscription = await subscriptionContract.subscriptions(
                subscriberAddress,
                userAccount
              )
              const expirationTime = new Date(subscription[0].toNumber() * 1000)
              const isActive = subscription[1] && expirationTime > new Date()
              const isYearly = subscription[2]

              html += `
                            <div class="subscription-card ${
                              isActive
                                ? "subscription-active"
                                : "subscription-expired"
                            }">
                                <h4>Subscriber</h4>
                                <p style="color: #666; font-size: 0.9em;">${subscriberAddress}</p>
                                <p><strong>Type:</strong> ${
                                  isYearly ? "Yearly" : "Monthly"
                                }</p>
                                <p><strong>Status:</strong> ${
                                  isActive ? "‚úÖ Active" : "‚ùå Expired"
                                }</p>
                                <p><strong>Expires:</strong> ${expirationTime.toLocaleString()}</p>
                            </div>
                        `
            } catch (error) {
              console.error(
                `Failed to load subscription for ${subscriberAddress}:`,
                error
              )
            }
          }

          subscribersList.innerHTML = html
        } catch (error) {
          showError(
            "Failed to load subscribers: " + getErrorMessage(error),
            "subscribersList"
          )
        }
      }

      async function withdrawEarnings() {
        try {
          showInfo("Withdrawing earnings...", "creatorStatus")
          const tx = await subscriptionContract.withdrawCreatorEarnings()
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "creatorStatus"
          )

          await tx.wait()
          showSuccess("Earnings withdrawn successfully!", "creatorStatus")

          await updateBalances()
          await loadCreatorStatus()
        } catch (error) {
          showError(
            "Failed to withdraw earnings: " + getErrorMessage(error),
            "creatorStatus"
          )
        }
      }

      async function stakeSTR() {
        try {
          const amount = document.getElementById("stakeAmount").value
          if (!amount) {
            throw new Error("Please enter amount to stake")
          }

          const amountWei = ethers.utils.parseEther(amount)

          const allowance = await strTokenContract.allowance(
            userAccount,
            SUBSCRIPTION_ADDRESS
          )
          if (allowance.lt(amountWei)) {
            showInfo("Approving STR spending...", "stakingResult")
            const approveTx = await strTokenContract.approve(
              SUBSCRIPTION_ADDRESS,
              ethers.constants.MaxUint256
            )
            await approveTx.wait()
          }

          showInfo("Staking STR...", "stakingResult")
          const tx = await subscriptionContract.stakeSTR(amountWei)
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "stakingResult"
          )

          await tx.wait()
          showSuccess(`Successfully staked ${amount} STR!`, "stakingResult")

          await updateBalances()
          await loadStakingInfo()
          document.getElementById("stakeAmount").value = ""
        } catch (error) {
          showError(
            "Failed to stake STR: " + getErrorMessage(error),
            "stakingResult"
          )
        }
      }

      async function unstakeSTR() {
        try {
          const amount = document.getElementById("unstakeAmount").value
          if (!amount) {
            throw new Error("Please enter amount to unstake")
          }

          const amountWei = ethers.utils.parseEther(amount)

          showInfo("Unstaking STR...", "stakingResult")
          const tx = await subscriptionContract.unstakeSTR(amountWei)
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "stakingResult"
          )

          await tx.wait()
          showSuccess(`Successfully unstaked ${amount} STR!`, "stakingResult")

          await updateBalances()
          await loadStakingInfo()
          document.getElementById("unstakeAmount").value = ""
        } catch (error) {
          showError(
            "Failed to unstake STR: " + getErrorMessage(error),
            "stakingResult"
          )
        }
      }

      async function claimGRNRewards() {
        try {
          showInfo("Claiming GRN rewards...", "stakingResult")
          const tx = await subscriptionContract.claimGRNRewards()
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "stakingResult"
          )

          await tx.wait()
          showSuccess("GRN rewards claimed successfully!", "stakingResult")

          await updateBalances()
          await loadStakingInfo()
        } catch (error) {
          showError(
            "Failed to claim GRN rewards: " + getErrorMessage(error),
            "stakingResult"
          )
        }
      }

      function switchTab(tabName) {
        document.querySelectorAll(".tab-content").forEach((content) => {
          content.classList.remove("active")
        })

        document.querySelectorAll(".tab").forEach((tab) => {
          tab.classList.remove("active")
        })

        document.getElementById(tabName + "Tab").classList.add("active")

        event.target.classList.add("active")
      }

      function getErrorMessage(error) {
        if (error.message.includes("Already registered")) {
          return "You are already registered as a creator."
        } else if (error.message.includes("Not a registered creator")) {
          return "You are not registered as a creator."
        } else if (error.message.includes("Creator not registered")) {
          return "This creator is not registered on the platform."
        } else if (error.message.includes("Insufficient STR balance")) {
          return "You don't have enough STR tokens."
        } else if (error.message.includes("Insufficient staked amount")) {
          return "You don't have enough staked STR tokens."
        } else if (error.message.includes("No earnings to withdraw")) {
          return "You have no earnings to withdraw."
        } else if (error.message.includes("No rewards to claim")) {
          return "You have no GRN rewards to claim."
        } else if (error.message.includes("Insufficient GRN in reward pool")) {
          return "The reward pool doesn't have enough GRN tokens. Please contact the platform administrator."
        } else if (error.message.includes("user rejected transaction")) {
          return "Transaction was cancelled."
        } else if (error.reason) {
          return error.reason
        } else {
          return error.message
        }
      }

      function showError(message, elementId) {
        const element = document.getElementById(elementId)
        element.innerHTML = `<div class="error">${message}</div>`
      }

      function showSuccess(message, elementId) {
        const element = document.getElementById(elementId)
        element.innerHTML = `<div class="success">${message}</div>`
      }

      function showInfo(message, elementId) {
        const element = document.getElementById(elementId)
        element.innerHTML = `<div class="info">${message}</div>`
      }

      window.addEventListener("load", async () => {
        if (window.ethereum && window.ethereum.selectedAddress) {
          await connectWallet()
        }
      })
    </script>
  </body>
</html>
