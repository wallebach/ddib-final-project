<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Subscription Platform</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="config.js"></script>
    <style>
      :root {
        --primary-color: #1ce783;
        --primary-hover: #16c46e;
        --primary-rgb: 28, 231, 131;
        --container-background: rgba(28, 30, 42, 0.6);
        --container-accent: rgba(255, 255, 255, 0.05);
        --text-color: #ffffff;
        --text-color-secondary: #b8bcc8;
        --network-selector-bg: rgba(28, 30, 42, 0.8);
        --network-info-bg: rgba(255, 255, 255, 0.05);
        --border-color: rgba(255, 255, 255, 0.1);
        --input-bg: rgba(255, 255, 255, 0.1);
        --input-border: rgba(255, 255, 255, 0.2);
        --tab-bg: rgba(28, 30, 42, 0.6);
        --tab-hover-bg: rgba(255, 255, 255, 0.05);
      }
      
      body {
        font-family: "Graphik", "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #0b0d17 0%, #1c1e2a 100%);
        color: var(--text-color);
        min-height: 100vh;
      }
      
      /* Navigation */
      .navbar {
        background: var(--network-selector-bg);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid var(--border-color);
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        transition: all 0.3s ease;
      }

      .nav-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        height: 70px;
      }

      .logo {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--primary-color);
        text-decoration: none;
        transition: all 0.3s ease;
      }

      .logo:hover {
        color: var(--primary-hover);
        transform: scale(1.05);
      }

      .nav-menu {
        display: flex;
        list-style: none;
        gap: 30px;
      }

      .nav-menu a {
        color: var(--text-color);
        text-decoration: none;
        font-weight: 500;
        transition: all 0.3s ease;
        padding: 10px 15px;
        border-radius: 8px;
        position: relative;
      }

      .nav-menu a:hover {
        color: var(--primary-color);
        background: rgba(var(--primary-rgb), 0.1);
      }

      .nav-menu a.active {
        color: var(--primary-color);
        background: rgba(var(--primary-rgb), 0.2);
      }

      .mobile-menu-toggle {
        display: none;
        background: none;
        border: none;
        color: var(--text-color);
        font-size: 1.5rem;
        cursor: pointer;
      }

      @media (max-width: 768px) {
        .nav-menu {
          position: fixed;
          top: 70px;
          left: -100%;
          width: 100%;
          height: calc(100vh - 70px);
          background: var(--network-selector-bg);
          flex-direction: column;
          align-items: center;
          justify-content: flex-start;
          padding-top: 50px;
          transition: left 0.3s ease;
        }

        .nav-menu.active {
          left: 0;
        }

        .mobile-menu-toggle {
          display: block;
        }
      }
      
      .network-selector {
        background: var(--network-selector-bg);
        padding: 15px 20px;
        border-bottom: 1px solid var(--border-color);
        backdrop-filter: blur(10px);
        color: var(--text-color);
        margin-top: 70px;
      }
      .network-selector select {
        padding: 8px 12px;
        border: 1px solid var(--input-border);
        border-radius: 8px;
        font-size: 14px;
        margin-left: 10px;
        background: var(--input-bg);
        color: var(--text-color);
        backdrop-filter: blur(10px);
      }
      .network-info {
        margin-top: 10px;
        padding: 10px;
        background: var(--network-info-bg);
        border-radius: 8px;
        font-size: 14px;
        color: var(--text-color-secondary);
      }
      .container {
        background: var(--container-background);
        padding: 30px;
        border-radius: 12px;
        backdrop-filter: blur(10px);
        border: 1px solid var(--border-color);
        margin: 20px;
      }
      .section-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }
      h1 {
        color: #000000;
        text-align: center;
        font-size: 2.5em;
        font-weight: 700;
        margin-bottom: 0;
        padding: 40px 20px 20px;
        background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-color) 100%);
        letter-spacing: -1px;
      }
      h2 {
        color: var(--text-color);
        font-weight: 600;
      }
      .status {
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
        font-weight: 600;
        text-align: center;
        backdrop-filter: blur(10px);
      }
      .status.connected {
        background: rgba(var(--primary-rgb), 0.2);
        color: var(--primary-color);
        border: 1px solid rgba(var(--primary-rgb), 0.3);
      }
      .status.disconnected {
        background: rgba(255, 107, 107, 0.2);
        color: #ff6b6b;
        border: 1px solid rgba(255, 107, 107, 0.3);
      }
      button {
        background: var(--primary-color);
        color: #000000;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        margin: 5px;
        font-weight: 600;
        transition: all 0.3s ease;
        letter-spacing: 0.5px;
      }
      button:hover {
        background: var(--primary-hover);
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(var(--primary-rgb), 0.3);
      }
      button:disabled {
        background: rgba(108, 117, 125, 0.5);
        color: rgba(255, 255, 255, 0.5);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      button.danger {
        background: #ff6b6b;
        color: #ffffff;
      }
      button.danger:hover {
        background: #ff5252;
        box-shadow: 0 8px 25px rgba(255, 107, 107, 0.3);
      }
      button.success {
        background: var(--primary-color);
        color: #000000;
      }
      button.success:hover {
        background: var(--primary-hover);
        box-shadow: 0 8px 25px rgba(var(--primary-rgb), 0.3);
      }
      input,
      textarea,
      select {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--input-border);
        border-radius: 8px;
        margin: 5px 0;
        box-sizing: border-box;
        background: var(--input-bg);
        color: var(--text-color);
        backdrop-filter: blur(10px);
      }
      input::placeholder,
      textarea::placeholder {
        color: var(--text-color-secondary);
        opacity: 0.7;
      }
      input:focus,
      textarea:focus,
      select:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.2);
      }
      .creator-card,
      .subscription-card {
        border: 1px solid var(--border-color);
        padding: 20px;
        margin: 15px 0;
        border-radius: 12px;
        background: var(--container-accent);
        backdrop-filter: blur(10px);
      }
      .subscription-active {
        border-left: 4px solid var(--primary-color);
      }
      .subscription-expired {
        border-left: 4px solid #ff6b6b;
      }
      .price-display {
        display: flex;
        justify-content: space-between;
        margin: 12px 0;
        font-weight: 600;
        color: var(--text-color);
      }
      .balance-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: var(--container-accent);
        padding: 12px;
        border-radius: 8px;
        margin: 12px 0;
        border: 1px solid var(--border-color);
        color: var(--text-color);
      }
      .error {
        color: #ff6b6b;
        background: rgba(255, 107, 107, 0.1);
        padding: 12px;
        border-radius: 8px;
        margin: 12px 0;
        border: 1px solid rgba(255, 107, 107, 0.2);
        backdrop-filter: blur(10px);
      }
      .success {
        color: var(--primary-color);
        background: rgba(var(--primary-rgb), 0.1);
        padding: 12px;
        border-radius: 8px;
        margin: 12px 0;
        border: 1px solid rgba(var(--primary-rgb), 0.2);
        backdrop-filter: blur(10px);
      }
      .info {
        color: #4fc3f7;
        background: rgba(79, 195, 247, 0.1);
        padding: 12px;
        border-radius: 8px;
        margin: 12px 0;
        border: 1px solid rgba(79, 195, 247, 0.2);
        backdrop-filter: blur(10px);
      }
      .tabs {
        display: flex;
        border-bottom: 2px solid var(--border-color);
        margin-bottom: 20px;
        background: var(--tab-bg);
        border-radius: 8px 8px 0 0;
        backdrop-filter: blur(10px);
      }
      .tab {
        padding: 12px 24px;
        cursor: pointer;
        border: none;
        background: none;
        border-bottom: 2px solid transparent;
        margin: 0;
        color: var(--text-color-secondary);
        font-weight: 500;
        transition: all 0.3s ease;
      }
      .tab:hover {
        color: var(--text-color);
        background: var(--tab-hover-bg);
      }
      .tab.active {
        border-bottom-color: var(--primary-color);
        color: var(--primary-color);
        font-weight: 600;
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      .staking-info {
        background: rgba(255, 193, 7, 0.1);
        border: 1px solid rgba(255, 193, 7, 0.2);
        padding: 18px;
        border-radius: 8px;
        margin: 12px 0;
        backdrop-filter: blur(10px);
        color: #ffc107;
      }
      .creator-browse-card {
        border: 1px solid var(--border-color);
        padding: 24px;
        margin: 18px 0;
        border-radius: 12px;
        background: var(--container-background);
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }
      .creator-browse-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        border-color: rgba(28, 231, 131, 0.3);
      }
      .creator-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      .creator-title {
        font-size: 1.3em;
        font-weight: 600;
        color: var(--text-color);
        word-break: break-all;
      }
      .subscriber-badge {
        background: var(--primary-color);
        color: #000000;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 0.85em;
        font-weight: 600;
      }
      .pricing-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin: 15px 0;
      }
      .price-card {
        background: var(--container-accent);
        padding: 18px;
        border-radius: 12px;
        text-align: center;
        border: 1px solid var(--border-color);
        backdrop-filter: blur(10px);
      }
      .price-card.recommended {
        border-color: var(--primary-color);
        background: rgba(var(--primary-rgb), 0.1);
      }
      .price-label {
        font-weight: 600;
        color: var(--text-color-secondary);
        margin-bottom: 8px;
      }
      .price-amount {
        font-size: 1.6em;
        font-weight: 700;
        color: var(--primary-color);
        margin-bottom: 8px;
      }
      .price-period {
        color: var(--text-color-secondary);
        font-size: 0.9em;
      }
      .subscribe-actions {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 15px;
      }
      .subscription-status {
        background: rgba(var(--primary-rgb), 0.1);
        color: var(--primary-color);
        padding: 12px;
        border-radius: 8px;
        margin-top: 12px;
        text-align: center;
        font-weight: 600;
        border: 1px solid rgba(var(--primary-rgb), 0.2);
        backdrop-filter: blur(10px);
      }
    </style>
  </head>
  <body>
    <!-- Navigation -->
    <nav class="navbar">
      <div class="nav-container">
        <a href="index.html" class="logo">Subscription Platform</a>
        <ul class="nav-menu">
          <li><a href="index.html">Home</a></li>
          <li><a href="governance-test.html">Governance</a></li>
          <li><a href="subscription-test.html" class="active">Subscription</a></li>
          <li><a href="video-gallery.html">Video Gallery</a></li>
          <li><a href="about.html">About</a></li>
        </ul>
        <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">‚ò∞</button>
      </div>
    </nav>

    <div class="network-selector">
      <label for="networkSelect">Select Network:</label>
      <select id="networkSelect" onchange="switchNetwork()">
        <option value="local">Local Development</option>
        <option value="sepolia">Sepolia Testnet</option>
        <option value="fuji">Avalanche Fuji</option>
        <option value="uzh">UZH_ETH_PoS</option>
      </select>
      <div id="networkInfo" class="network-info"></div>
    </div>

    <h1>Subscription Platform</h1>

    <div class="container">
      <h2>Connection Status</h2>
      <div id="connectionStatus" class="status disconnected">Not Connected</div>
      <button onclick="connectWallet()" id="connectBtn">
        Connect MetaMask
      </button>
      <div id="accountInfo" style="display: none">
        <p><strong>Account:</strong> <span id="accountAddress"></span></p>
        <div class="balance-info">
          <span
            ><strong>STR Balance:</strong>
            <span id="strBalance">0</span> STR</span
          >
          <span
            ><strong>GRN Balance:</strong>
            <span id="grnBalance">0</span> GRN</span
          >
          <span
            ><strong>Staked STR:</strong>
            <span id="stakedBalance">0</span> STR</span
          >
        </div>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" onclick="switchTab('creator')">
        Creator Dashboard
      </button>
      <button class="tab" onclick="switchTab('subscriber')">
        Subscriber Dashboard
      </button>
      <button class="tab" onclick="switchTab('staking')">Staking</button>
    </div>

    <div id="creatorTab" class="tab-content active">
      <div class="section-grid">
        <div class="container">
          <h2>Creator Registration</h2>
          <div id="creatorStatus"></div>
          <div id="creatorRegistrationForm">
            <input
              type="text"
              id="creatorName"
              placeholder="Your Creator Name"
              maxlength="50"
            />
            <input
              type="number"
              id="monthlyPrice"
              placeholder="Monthly Price (STR)"
              step="0.01"
            />
            <input
              type="number"
              id="yearlyPrice"
              placeholder="Yearly Price (STR)"
              step="0.01"
            />
            <button
              onclick="registerCreator()"
              id="registerCreatorBtn"
              disabled
            >
              Register as Creator
            </button>
          </div>
          <div id="creatorUpdateForm" style="display: none">
            <input
              type="number"
              id="updateMonthlyPrice"
              placeholder="New Monthly Price (STR)"
              step="0.01"
            />
            <input
              type="number"
              id="updateYearlyPrice"
              placeholder="New Yearly Price (STR)"
              step="0.01"
            />
            <button onclick="updateCreatorPrices()" class="success">
              Update Prices
            </button>
          </div>
        </div>

        <div class="container">
          <h2>Creator Earnings</h2>
          <div id="creatorEarnings">
            <div class="balance-info">
              <span
                ><strong>Total Earnings:</strong>
                <span id="totalEarnings">0</span> STR</span
              >
              <span
                ><strong>Subscribers:</strong>
                <span id="subscriberCount">0</span></span
              >
            </div>
            <button onclick="withdrawEarnings()" id="withdrawBtn" disabled>
              Withdraw Earnings
            </button>
          </div>
        </div>
      </div>

      <div class="container">
        <h2>My Subscribers</h2>
        <button onclick="loadMySubscribers()" id="loadSubscribersBtn" disabled>
          Load Subscribers
        </button>
        <div id="subscribersList"></div>
      </div>
    </div>

    <div id="subscriberTab" class="tab-content">
      <div class="container">
        <h2>Discover Creators</h2>
        <button onclick="loadAllCreators()" id="loadCreatorsBtn" disabled>
          Load All Creators
        </button>
        <div id="creatorsList"></div>
      </div>

      <div class="section-grid">
        <div class="container">
          <h2>Search Specific Creator</h2>
          <input
            type="text"
            id="creatorAddress"
            placeholder="Enter creator address"
          />
          <button onclick="loadCreatorInfo()" id="loadCreatorBtn" disabled>
            Load Creator Info
          </button>
          <div id="creatorInfo"></div>
        </div>

        <div class="container">
          <h2>Quick Subscribe</h2>
          <input
            type="text"
            id="subscribeCreatorAddress"
            placeholder="Creator address"
            readonly
          />
          <select id="subscriptionType">
            <option value="false">Monthly Subscription</option>
            <option value="true">Yearly Subscription</option>
          </select>
          <button onclick="subscribeToCreator()" id="subscribeBtn" disabled>
            Subscribe
          </button>
          <div id="subscribeResult"></div>
        </div>
      </div>

      <div class="container">
        <h2>My Subscriptions</h2>
        <button
          onclick="loadMySubscriptions()"
          id="loadSubscriptionsBtn"
          disabled
        >
          Load My Subscriptions
        </button>
        <div id="subscriptionsList"></div>
      </div>
    </div>

    <div id="stakingTab" class="tab-content">
      <div class="container">
        <h2>STR Staking</h2>
        <div class="staking-info">
          <h3>Staking Information</h3>
          <p>
            <strong>Your Staked Amount:</strong>
            <span id="stakedAmount">0</span> STR
          </p>
          <p>
            <strong>Pending GRN Rewards:</strong>
            <span id="pendingRewards">0</span> GRN
            <button
              onclick="loadPendingRewards()"
              style="margin-left: 10px; padding: 5px 10px; font-size: 0.8em"
            >
              Load Rewards
            </button>
          </p>
        </div>

        <div class="section-grid">
          <div>
            <h3>Stake STR</h3>
            <input
              type="number"
              id="stakeAmount"
              placeholder="Amount to stake (STR)"
              step="0.01"
            />
            <button onclick="stakeSTR()" id="stakeBtn" disabled>
              Stake STR
            </button>
          </div>

          <div>
            <h3>Unstake STR</h3>
            <input
              type="number"
              id="unstakeAmount"
              placeholder="Amount to unstake (STR)"
              step="0.01"
            />
            <button
              onclick="unstakeSTR()"
              id="unstakeBtn"
              disabled
              class="danger"
            >
              Unstake STR
            </button>
          </div>
        </div>

        <button
          onclick="claimGRNRewards()"
          id="claimBtn"
          disabled
          class="success"
        >
          Claim GRN Rewards
        </button>
        <div id="stakingResult"></div>
      </div>
    </div>

    <script>
      // Contract addresses are now dynamically loaded from config
      let SUBSCRIPTION_ADDRESS = NetworkUtils.getContractAddress(
        "SubscriptionPlatform"
      )
      let STR_TOKEN_ADDRESS = NetworkUtils.getContractAddress("STRToken")
      let GRN_TOKEN_ADDRESS = NetworkUtils.getContractAddress("GRNToken")

      const SUBSCRIPTION_ABI = [
        "function registerCreator(string memory _name, uint256 _monthlyPrice, uint256 _yearlyPrice) external",
        "function updateCreatorPrices(uint256 _monthlyPrice, uint256 _yearlyPrice) external",
        "function subscribeToCreator(address creator, bool isYearly) external",
        "function stakeSTR(uint256 amount) external",
        "function unstakeSTR(uint256 amount) external",
        "function claimGRNRewards() external",
        "function withdrawCreatorEarnings() external",
        "function isSubscriptionActive(address subscriber, address creator) external view returns (bool)",
        "function getCreatorInfo(address creator) external view returns (bool, string, uint256, uint256, uint256, uint256)",
        "function getUserSubscribedCreators(address user) external view returns (address[])",
        "function getCreatorSubscribers(address creator) external view returns (address[])",
        "function calculateGRNReward(address user) external view returns (uint256)",
        "function creators(address) external view returns (bool, string, uint256, uint256, uint256, uint256)",
        "function subscriptions(address, address) external view returns (uint256, bool, bool)",
        "function stakedSTR(address) external view returns (uint256)",
        "function stakingTimestamp(address) external view returns (uint256)",
        "event SubscriptionPurchased(address indexed subscriber, address indexed creator, uint256 amount, uint256 expiration, bool isYearly)",
        "event CreatorRegistered(address indexed creator, string name, uint256 monthlyPrice, uint256 yearlyPrice)",
        "event STRStaked(address indexed user, uint256 amount)",
        "event STRUnstaked(address indexed user, uint256 amount)",
        "event GRNRewardClaimed(address indexed user, uint256 amount)",
      ]

      const TOKEN_ABI = [
        "function balanceOf(address owner) view returns (uint256)",
        "function decimals() view returns (uint8)",
        "function approve(address spender, uint256 amount) returns (bool)",
        "function allowance(address owner, address spender) view returns (uint256)",
      ]

      let provider
      let signer
      let subscriptionContract
      let strTokenContract
      let grnTokenContract
      let userAccount
      let allCreators = []
      let creatorsLoaded = false
      let stakingRefreshInterval

      // Network switching functions
      function updateNetworkInfo() {
        const config = NetworkUtils.getNetworkConfig()
        const theme = ThemeUtils.getCurrentTheme()
        const networkInfo = document.getElementById("networkInfo")
        networkInfo.innerHTML = `<strong>Network:</strong> ${config.name} | <strong>Chain ID:</strong> ${config.chainId} | <strong>Theme:</strong> ${theme.name}`
      }

      async function switchNetwork() {
        const networkSelect = document.getElementById("networkSelect")
        const selectedNetwork = networkSelect.value

        try {
          // Clear existing contracts before switching
          subscriptionContract = null
          strTokenContract = null
          grnTokenContract = null
          
          await NetworkUtils.switchNetwork(selectedNetwork)

          // Update contract addresses
          SUBSCRIPTION_ADDRESS = NetworkUtils.getContractAddress(
            "SubscriptionPlatform"
          )
          STR_TOKEN_ADDRESS = NetworkUtils.getContractAddress("STRToken")
          GRN_TOKEN_ADDRESS = NetworkUtils.getContractAddress("GRNToken")

          updateNetworkInfo()

          // Force a complete wallet reconnection to ensure new provider/signer
          if (userAccount) {
            // Reset connection state
            provider = null
            signer = null
            
            // Wait a bit for network switch to complete
            await new Promise(resolve => setTimeout(resolve, 1000))
            
            // Reconnect with proper error handling
            await connectWallet()
            
            // Verify contracts are working by testing a simple call
            if (subscriptionContract && strTokenContract) {
              try {
                // Test contract connectivity with the new network
                await strTokenContract.balanceOf(userAccount)
                console.log("Contract connectivity verified for", selectedNetwork)
              } catch (contractError) {
                console.error("Contract connectivity test failed:", contractError)
                throw new Error(`Contracts not properly connected to ${selectedNetwork} network. Please try switching again.`)
              }
            }
          }

          alert(
            `Successfully switched to ${NetworkUtils.getNetworkConfig().name}`
          )
        } catch (error) {
          console.error("Network switch failed:", error)
          alert("Failed to switch network: " + error.message)
          // Revert select to current network
          networkSelect.value = NetworkUtils.getCurrentNetwork()
          
          // If we had a user account, try to reconnect to the original network
          if (userAccount) {
            try {
              await connectWallet()
            } catch (reconnectError) {
              console.error("Failed to reconnect to original network:", reconnectError)
            }
          }
        }
      }

      // Initialize network UI
      function initializeNetworkUI() {
        const networkSelect = document.getElementById("networkSelect")
        networkSelect.value = NetworkUtils.getCurrentNetwork()
        ThemeUtils.applyTheme()
        updateNetworkInfo()
      }

      async function connectWallet() {
        try {
          if (!window.ethereum) {
            throw new Error("MetaMask not found!")
          }

          // Initialize network UI if not already done
          if (!document.getElementById("networkSelect").value) {
            initializeNetworkUI()
          }

          provider = new ethers.providers.Web3Provider(window.ethereum)
          await provider.send("eth_requestAccounts", [])
          signer = provider.getSigner()
          userAccount = await signer.getAddress()

          // Verify we're on the correct network
          const network = await provider.getNetwork()
          const expectedChainId = NetworkUtils.getNetworkConfig().chainId
          const expectedChainIdDecimal = parseInt(expectedChainId, 16)
          
          if (network.chainId !== expectedChainIdDecimal) {
            console.warn(`Network mismatch: expected ${expectedChainIdDecimal}, got ${network.chainId}`)
          }

          // Initialize contracts with current network addresses
          subscriptionContract = new ethers.Contract(
            SUBSCRIPTION_ADDRESS,
            SUBSCRIPTION_ABI,
            signer
          )
          strTokenContract = new ethers.Contract(
            STR_TOKEN_ADDRESS,
            TOKEN_ABI,
            signer
          )
          grnTokenContract = new ethers.Contract(
            GRN_TOKEN_ADDRESS,
            TOKEN_ABI,
            provider
          )

          // Verify contract addresses are valid
          console.log("Contract addresses for", NetworkUtils.getCurrentNetwork() + ":")
          console.log("  SubscriptionPlatform:", SUBSCRIPTION_ADDRESS)
          console.log("  STRToken:", STR_TOKEN_ADDRESS)
          console.log("  GRNToken:", GRN_TOKEN_ADDRESS)
          console.log("  Network Chain ID:", network.chainId)

          document.getElementById("connectionStatus").textContent = "Connected"
          document.getElementById("connectionStatus").className =
            "status connected"
          document.getElementById("accountAddress").textContent = userAccount
          document.getElementById("accountInfo").style.display = "block"
          document.getElementById("connectBtn").disabled = true

          enableAllButtons()

          // Update balances with proper error handling
          try {
            await updateBalances()
          } catch (balanceError) {
            console.error("Failed to update balances:", balanceError)
            showError(
              "Connected to wallet but failed to load token balances. Please verify you're on the correct network.",
              "subscribeResult"
            )
          }

          await loadCreatorStatus()
          await loadStakingInfo()

          startStakingRefresh()

          if (creatorsLoaded && allCreators.length > 0) {
            await refreshCreatorSubscriptionStatus()
          }

          showSuccess("Successfully connected to MetaMask!", "subscribeResult")
        } catch (error) {
          showError(
            "Failed to connect wallet: " + error.message,
            "subscribeResult"
          )
        }
      }

      function enableAllButtons() {
        const buttons = [
          "registerCreatorBtn",
          "loadCreatorBtn",
          "subscribeBtn",
          "loadSubscriptionsBtn",
          "loadSubscribersBtn",
          "withdrawBtn",
          "stakeBtn",
          "unstakeBtn",
          "claimBtn",
          "loadCreatorsBtn",
        ]
        buttons.forEach((id) => {
          const btn = document.getElementById(id)
          if (btn) btn.disabled = false
        })
      }

      async function updateBalances() {
        try {
          if (!userAccount || !strTokenContract || !grnTokenContract || !subscriptionContract) {
            console.log("Cannot update balances: missing userAccount or contracts")
            return
          }

          console.log("Updating balances for", userAccount, "on", NetworkUtils.getCurrentNetwork())

          const [strBalance, grnBalance, stakedBalance] = await Promise.all([
            strTokenContract.balanceOf(userAccount),
            grnTokenContract.balanceOf(userAccount),
            subscriptionContract.stakedSTR(userAccount),
          ])

          const strFormatted = ethers.utils.formatEther(strBalance)
          const grnFormatted = ethers.utils.formatEther(grnBalance)
          const stakedFormatted = ethers.utils.formatEther(stakedBalance)

          console.log("Balance update successful:")
          console.log("  STR Balance:", strFormatted)
          console.log("  GRN Balance:", grnFormatted)
          console.log("  Staked STR:", stakedFormatted)

          document.getElementById("strBalance").textContent = strFormatted
          document.getElementById("grnBalance").textContent = grnFormatted
          document.getElementById("stakedBalance").textContent = stakedFormatted
          document.getElementById("stakedAmount").textContent = stakedFormatted
        } catch (error) {
          console.error("Failed to update balances:", error)
          console.error("Network:", NetworkUtils.getCurrentNetwork())
          console.error("Contract addresses:", {
            STRToken: STR_TOKEN_ADDRESS,
            GRNToken: GRN_TOKEN_ADDRESS,
            SubscriptionPlatform: SUBSCRIPTION_ADDRESS
          })
          
          // Set balances to error state
          document.getElementById("strBalance").textContent = "Error"
          document.getElementById("grnBalance").textContent = "Error"
          document.getElementById("stakedBalance").textContent = "Error"
          document.getElementById("stakedAmount").textContent = "Error"
          
          throw error // Re-throw to let calling function handle it
        }
      }

      async function loadCreatorStatus() {
        try {
          const creatorInfo = await subscriptionContract.creators(userAccount)
          const isRegistered = creatorInfo[0]

          if (isRegistered) {
            const creatorName = creatorInfo[1]
            const monthlyPrice = ethers.utils.formatEther(creatorInfo[2])
            const yearlyPrice = ethers.utils.formatEther(creatorInfo[3])
            const totalEarnings = ethers.utils.formatEther(creatorInfo[4])
            const subscriberCount = creatorInfo[5].toString()

            console.log("‚úÖ Creator found:", { creatorName, monthlyPrice, yearlyPrice, totalEarnings, subscriberCount })
            document.getElementById("creatorStatus").innerHTML = `
                        <div class="success">‚úÖ You are registered as creator: <strong>${creatorName}</strong></div>
                        <div style="background: rgba(76, 175, 80, 0.1); padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 0.9em;">
                            <strong>Network:</strong> ${NetworkUtils.getCurrentNetwork()} | 
                            <strong>Contract:</strong> ${SUBSCRIPTION_ADDRESS.substring(0, 10)}...
                        </div>
                        <div class="price-display">
                            <span>Monthly: ${monthlyPrice} STR</span>
                            <span>Yearly: ${yearlyPrice} STR</span>
                        </div>
                    `
            document.getElementById("creatorRegistrationForm").style.display =
              "none"
            document.getElementById("creatorUpdateForm").style.display = "block"
            document.getElementById("totalEarnings").textContent = totalEarnings
            document.getElementById("subscriberCount").textContent =
              subscriberCount

            document.getElementById("updateMonthlyPrice").value = monthlyPrice
            document.getElementById("updateYearlyPrice").value = yearlyPrice
          } else {
            console.log("‚ÑπÔ∏è User is not registered as a creator")
            document.getElementById("creatorStatus").innerHTML = `
                        <div class="info">You are not registered as a creator on ${NetworkUtils.getCurrentNetwork()} yet.</div>
                    `
          }
        } catch (error) {
          console.error("Failed to load creator status:", error)
        }
      }

      async function loadStakingInfo() {
        console.log("üîç Starting loadStakingInfo...")

        if (!userAccount || !subscriptionContract) {
          console.log("Missing userAccount or subscriptionContract")
          return
        }

        try {
          console.log("Connected, fetching data for:", userAccount)

          console.log("Getting staked amount...")
          const stakedAmount = await subscriptionContract.stakedSTR(userAccount)
          console.log(
            "Got staked amount:",
            ethers.utils.formatEther(stakedAmount)
          )

          console.log("Getting staking timestamp...")
          const stakingTimestamp = await subscriptionContract.stakingTimestamp(
            userAccount
          )
          console.log("Got staking timestamp:", stakingTimestamp.toString())

          console.log("Getting current block...")
          const currentBlock = await provider.getBlock("latest")
          console.log(
            "Got current block:",
            currentBlock.number,
            "timestamp:",
            currentBlock.timestamp
          )

          console.log("Getting pending rewards...")
          const pendingRewards = await subscriptionContract.calculateGRNReward(
            userAccount
          )
          console.log(
            "Got pending rewards:",
            ethers.utils.formatEther(pendingRewards)
          )

          const stakingTime = stakingTimestamp.toNumber()
          const blockTimestamp = currentBlock.timestamp
          const stakingDuration =
            stakingTime > 0 ? blockTimestamp - stakingTime : 0

          console.log("Calculation results:")
          console.log("  - Staked STR:", ethers.utils.formatEther(stakedAmount))
          console.log("  - Staking timestamp:", stakingTime)
          console.log("  - Block timestamp:", blockTimestamp)
          console.log("  - Duration:", stakingDuration, "seconds")
          console.log(
            "  - Pending rewards:",
            ethers.utils.formatEther(pendingRewards)
          )

          console.log("Updating UI elements...")
          document.getElementById("stakedAmount").textContent =
            ethers.utils.formatEther(stakedAmount)
          document.getElementById("pendingRewards").textContent =
            ethers.utils.formatEther(pendingRewards)

          console.log("loadStakingInfo completed successfully")
        } catch (error) {
          console.error("Failed to load staking info:", error)
          console.error("Error details:", error.message)
          console.error("Error stack:", error.stack)
        }
      }

      window.testRewardsDirectly = async function () {
        try {
          console.log("üß™ Direct contract testing...")

          const stakedAmount = await subscriptionContract.stakedSTR(userAccount)
          const stakingTimestamp = await subscriptionContract.stakingTimestamp(
            userAccount
          )
          const pendingRewards = await subscriptionContract.calculateGRNReward(
            userAccount
          )
          const currentBlock = await provider.getBlock("latest")

          console.log("üîç Raw contract data:")
          console.log("  - Staked STR (wei):", stakedAmount.toString())
          console.log("  - Staking timestamp:", stakingTimestamp.toString())
          console.log("  - Block timestamp:", currentBlock.timestamp)
          console.log(
            "  - Duration:",
            currentBlock.timestamp - stakingTimestamp.toNumber()
          )
          console.log("  - Pending rewards (wei):", pendingRewards.toString())
          console.log(
            "  - Pending rewards (ether):",
            ethers.utils.formatEther(pendingRewards)
          )

          return {
            stakedAmount: stakedAmount.toString(),
            stakingTimestamp: stakingTimestamp.toString(),
            blockTimestamp: currentBlock.timestamp,
            pendingRewards: pendingRewards.toString(),
            formattedRewards: ethers.utils.formatEther(pendingRewards),
          }
        } catch (error) {
          console.error("Direct test failed:", error)
          return error
        }
      }

      async function loadPendingRewards() {
        console.log(
          "üîÑ Making transaction to update blockchain and load pending rewards..."
        )

        if (!userAccount || !subscriptionContract) {
          console.log("Not connected to wallet or contract")
          alert("Please connect your wallet first")
          return
        }

        try {
          const button = document.querySelector(
            'button[onclick="loadPendingRewards()"]'
          )
          if (button) {
            button.textContent = "‚è≥ Loading..."
            button.disabled = true
          }

          console.log(
            "üì° Making a small transaction to update blockchain timestamp..."
          )

          const currentAllowance = await strTokenContract.allowance(
            userAccount,
            SUBSCRIPTION_ADDRESS
          )
          console.log(
            "Current STR allowance:",
            ethers.utils.formatEther(currentAllowance)
          )

          const tx = await strTokenContract.approve(
            SUBSCRIPTION_ADDRESS,
            currentAllowance
          )
          console.log("üîó Transaction sent:", tx.hash)
          console.log("‚è≥ Waiting for transaction confirmation...")

          const receipt = await tx.wait()
          console.log("Transaction confirmed in block:", receipt.blockNumber)

          console.log(" Getting updated staking data...")
          const newBlock = await provider.getBlock("latest")
          console.log(
            "Active New block:",
            newBlock.number,
            "timestamp:",
            newBlock.timestamp
          )

          const [stakedAmount, stakingTimestamp, pendingRewards] =
            await Promise.all([
              subscriptionContract.stakedSTR(userAccount),
              subscriptionContract.stakingTimestamp(userAccount),
              subscriptionContract.calculateGRNReward(userAccount),
            ])

          console.log(
            "Active Staked amount:",
            ethers.utils.formatEther(stakedAmount),
            "STR"
          )
          console.log("Staking timestamp:", stakingTimestamp.toString())
          console.log("Raw pending rewards:", pendingRewards.toString())
          console.log(
            "Active Formatted pending rewards:",
            ethers.utils.formatEther(pendingRewards),
            "GRN"
          )

          const stakingTime = stakingTimestamp.toNumber()
          const blockTimestamp = newBlock.timestamp
          const stakingDuration =
            stakingTime > 0 ? blockTimestamp - stakingTime : 0

          console.log("üßÆ Verification calculations:")
          console.log("  - Staking duration:", stakingDuration, "seconds")
          console.log(
            "  - Expected rate: 100% per minute =",
            (100 / 60).toFixed(3),
            "% per second"
          )

          if (stakingDuration > 0 && stakedAmount.gt(0)) {
            const stakedSTRAmount = parseFloat(
              ethers.utils.formatEther(stakedAmount)
            )
            const expectedReward =
              (stakedSTRAmount * 1.0 * stakingDuration) / 60
            console.log(
              "  - Manual calculation:",
              expectedReward.toFixed(6),
              "GRN"
            )
            console.log(
              "  - Contract calculation:",
              ethers.utils.formatEther(pendingRewards),
              "GRN"
            )

            if (
              Math.abs(
                expectedReward -
                  parseFloat(ethers.utils.formatEther(pendingRewards))
              ) < 0.000001
            ) {
              console.log("Calculations match!")
            } else {
              console.log("‚ö†Ô∏è  Calculation mismatch detected")
            }
          }

          document.getElementById("pendingRewards").textContent =
            ethers.utils.formatEther(pendingRewards)

          console.log(
            "üéâ Transaction completed! Pending rewards:",
            ethers.utils.formatEther(pendingRewards),
            "GRN"
          )

          if (button) {
            button.textContent = "Active Updated!"
            button.style.backgroundColor = "#28a745"
            button.disabled = false

            setTimeout(() => {
              button.textContent = "Load Rewards"
              button.style.backgroundColor = ""
            }, 3000)
          }
        } catch (error) {
          console.error("Expired Failed to load pending rewards:", error)
          alert("Failed to load rewards: " + error.message)

          const button = document.querySelector(
            'button[onclick="loadPendingRewards()"]'
          )
          if (button) {
            button.textContent = "Load Rewards"
            button.disabled = false
            button.style.backgroundColor = ""
          }
        }
      }

      async function forceUpdate() {
        console.log(" Force updating blockchain state...")

        if (!userAccount || !subscriptionContract) {
          console.log("Not connected to wallet or contract")
          return
        }

        try {
          console.log(" Refreshing staking data...")
          await loadStakingInfo()
          console.log("Force update completed")
        } catch (error) {
          console.error("Expired Force update failed:", error)
        }
      }

      function startStakingRefresh() {
        if (stakingRefreshInterval) {
          clearInterval(stakingRefreshInterval)
        }

        stakingRefreshInterval = setInterval(async () => {
          if (userAccount && subscriptionContract) {
            await loadStakingInfo()
          }
        }, 5000)
      }

      async function refreshRewards() {
        console.log("üîÑ Manual reward refresh requested")

        if (!userAccount || !subscriptionContract) {
          console.log("Not connected to wallet or contract")
          return
        }

        try {
          const currentBlockNumber = await provider.getBlockNumber()
          const currentBlock = await provider.getBlock(currentBlockNumber)
          const blockTimestamp = currentBlock.timestamp

          console.log("üîó Blockchain data:")
          console.log("  - Current block:", currentBlockNumber)
          console.log(
            "  - Block timestamp:",
            blockTimestamp,
            new Date(blockTimestamp * 1000).toLocaleTimeString()
          )

          const [stakedAmount, stakingTimestamp, pendingRewards] =
            await Promise.all([
              subscriptionContract.stakedSTR(userAccount),
              subscriptionContract.stakingTimestamp(userAccount),
              subscriptionContract.calculateGRNReward(userAccount),
            ])

          const stakingTime = stakingTimestamp.toNumber()
          const stakingDuration =
            stakingTime > 0 ? blockTimestamp - stakingTime : 0

          console.log(" Fresh reward data:")
          console.log(
            "  - Staked amount:",
            ethers.utils.formatEther(stakedAmount),
            "STR"
          )
          console.log(
            "  - Staking timestamp:",
            stakingTime,
            new Date(stakingTime * 1000).toLocaleTimeString()
          )
          console.log("  - Duration:", stakingDuration, "seconds")
          console.log("  - Raw rewards:", pendingRewards.toString())
          console.log(
            "  - Formatted rewards:",
            ethers.utils.formatEther(pendingRewards),
            "GRN"
          )

          document.getElementById("pendingRewards").textContent =
            ethers.utils.formatEther(pendingRewards)

          console.log("Rewards updated successfully!")
        } catch (error) {
          console.error("Expired Failed to refresh rewards:", error)
        }
      }

      async function registerCreator() {
        try {
          const creatorName = document
            .getElementById("creatorName")
            .value.trim()
          const monthlyPrice = document.getElementById("monthlyPrice").value
          const yearlyPrice = document.getElementById("yearlyPrice").value

          if (!creatorName) {
            throw new Error("Please enter your creator name")
          }
          if (!monthlyPrice || !yearlyPrice) {
            throw new Error("Please enter both monthly and yearly prices")
          }

          const monthlyPriceWei = ethers.utils.parseEther(monthlyPrice)
          const yearlyPriceWei = ethers.utils.parseEther(yearlyPrice)

          console.log("Creator registration details:")
          console.log("  Name:", creatorName)
          console.log("  Monthly Price:", monthlyPrice, "STR")
          console.log("  Yearly Price:", yearlyPrice, "STR")
          console.log("  Network:", NetworkUtils.getCurrentNetwork())
          console.log("  Contract:", SUBSCRIPTION_ADDRESS)

          // Check if user is already registered
          try {
            const creatorInfo = await subscriptionContract.creators(userAccount)
            if (creatorInfo[0]) {
              throw new Error("You are already registered as a creator")
            }
          } catch (checkError) {
            console.warn("Could not check existing creator status:", checkError.message)
          }

          // Try to estimate gas first, but don't fail if it doesn't work
          showInfo("Estimating transaction cost...", "creatorStatus")
          let gasLimit = 250000; // Default gas limit
          try {
            const gasEstimate = await subscriptionContract.estimateGas.registerCreator(
              creatorName,
              monthlyPriceWei,
              yearlyPriceWei
            )
            gasLimit = gasEstimate.mul(120).div(100); // Add 20% buffer
            console.log("Gas estimate:", gasEstimate.toString(), "-> Using:", gasLimit.toString())
          } catch (gasError) {
            console.warn("Gas estimation failed, using default gas limit:", gasError.message)
            console.log("This might indicate network issues or insufficient funds")
            
            // Check if we're on UZH network and suggest alternatives
            if (NetworkUtils.getCurrentNetwork() === 'uzh') {
              showInfo("Gas estimation failed on UZH network. Proceeding with default gas limit. If this fails, you may need UZHETHs for gas fees.", "creatorStatus")
              
              // Check if user has any balance
              try {
                const balance = await provider.getBalance(userAccount)
                if (balance.eq(0)) {
                  showError("No UZHETHs found in your wallet. You need UZHETHs for gas fees on the UZH network. Consider testing on Fuji network first.", "creatorStatus")
                  return
                }
              } catch (balanceError) {
                console.warn("Could not check balance:", balanceError.message)
              }
            } else {
              console.log("Using default gas limit of", gasLimit)
            }
          }

          showInfo("Registering as creator...", "creatorStatus")
          const tx = await subscriptionContract.registerCreator(
            creatorName,
            monthlyPriceWei,
            yearlyPriceWei,
            {
              gasLimit: gasLimit
            }
          )
          
          console.log("Transaction sent:", tx.hash)
          showInfo(
            `Transaction sent (${tx.hash.substring(0, 10)}...). Waiting for confirmation...`,
            "creatorStatus"
          )

          const receipt = await tx.wait()
          console.log("Transaction confirmed:", receipt)
          
          // Check if transaction was successful
          if (receipt.status === 0) {
            throw new Error("Transaction was mined but failed during execution")
          }
          
          showSuccess("Successfully registered as creator!", "creatorStatus")

          await loadCreatorStatus()
          document.getElementById("creatorName").value = ""
          document.getElementById("monthlyPrice").value = ""
          document.getElementById("yearlyPrice").value = ""
        } catch (error) {
          console.error("Creator registration error:", error)
          
          // Enhanced debugging for transaction failures
          if (error.message.includes("transaction failed") || error.message.includes("Transaction was mined but failed")) {
            console.log("Transaction failed during execution. Checking possible causes...")
            
            // Check if user is already registered (common cause)
            try {
              const creatorInfo = await subscriptionContract.creators(userAccount)
              if (creatorInfo[0]) {
                showError("You are already registered as a creator! Your current settings: " + 
                         creatorInfo[1] + " (" + 
                         ethers.utils.formatEther(creatorInfo[2]) + " STR/month, " + 
                         ethers.utils.formatEther(creatorInfo[3]) + " STR/year)", "creatorStatus")
                return
              }
            } catch (checkError) {
              console.warn("Could not verify creator status:", checkError.message)
            }
            
            // Check for zero prices (another common cause)
            const monthlyPrice = document.getElementById("monthlyPrice").value
            const yearlyPrice = document.getElementById("yearlyPrice").value
            if (parseFloat(monthlyPrice) <= 0 || parseFloat(yearlyPrice) <= 0) {
              showError("Invalid prices! Both monthly and yearly prices must be greater than 0.", "creatorStatus")
              return
            }
            
            // Provide general guidance
            showError("Transaction failed during execution. This usually means: 1) You're already registered, 2) Invalid price values, or 3) Contract validation failed. Check the console for details.", "creatorStatus")
          } else {
            showError(
              "Failed to register as creator: " + getErrorMessage(error),
              "creatorStatus"
            )
          }
        }
      }

      async function updateCreatorPrices() {
        try {
          const monthlyPrice =
            document.getElementById("updateMonthlyPrice").value
          const yearlyPrice = document.getElementById("updateYearlyPrice").value

          if (!monthlyPrice || !yearlyPrice) {
            throw new Error("Please enter both monthly and yearly prices")
          }

          const monthlyPriceWei = ethers.utils.parseEther(monthlyPrice)
          const yearlyPriceWei = ethers.utils.parseEther(yearlyPrice)

          showInfo("Updating prices...", "creatorStatus")
          const tx = await subscriptionContract.updateCreatorPrices(
            monthlyPriceWei,
            yearlyPriceWei
          )
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "creatorStatus"
          )

          await tx.wait()
          showSuccess("Prices updated successfully!", "creatorStatus")

          await loadCreatorStatus()
        } catch (error) {
          showError(
            "Failed to update prices: " + getErrorMessage(error),
            "creatorStatus"
          )
        }
      }

      async function loadAllCreators() {
        try {
          showInfo("Loading all creators...", "creatorsList")

          const currentBlock = await provider.getBlockNumber()
          console.log("Current block:", currentBlock)

          const filter = subscriptionContract.filters.CreatorRegistered()
          const events = await subscriptionContract.queryFilter(
            filter,
            Math.max(0, currentBlock - 1000),
            "latest"
          )

          console.log("Found creator events:", events.length)

          if (events.length === 0) {
            document.getElementById("creatorsList").innerHTML = `
                        <div class="info">
                            <p>No creators found on the platform yet.</p>
                            <p>Be the first to register as a creator in the "Creator Dashboard" tab!</p>
                        </div>
                    `
            return
          }

          const creatorAddresses = [
            ...new Set(events.map((event) => event.args.creator)),
          ]
          allCreators = []

          console.log(
            "Checking registration status for creators:",
            creatorAddresses
          )

          let html = ""
          for (const creatorAddress of creatorAddresses) {
            try {
              console.log(`Checking creator: ${creatorAddress}`)

              const creatorInfo = await subscriptionContract.getCreatorInfo(
                creatorAddress
              )
              const isRegistered = creatorInfo[0]

              console.log(`Creator ${creatorAddress} registered:`, isRegistered)

              if (!isRegistered) {
                console.log(`Skipping unregistered creator: ${creatorAddress}`)
                continue
              }

              const [isSubscribed, subscription] = await Promise.all([
                subscriptionContract.isSubscriptionActive(
                  userAccount,
                  creatorAddress
                ),
                subscriptionContract.subscriptions(userAccount, creatorAddress),
              ])

              const creatorName = creatorInfo[1]
              const monthlyPrice = ethers.utils.formatEther(creatorInfo[2])
              const yearlyPrice = ethers.utils.formatEther(creatorInfo[3])
              const subscriberCount = creatorInfo[5].toString()

              const monthlyCost = parseFloat(monthlyPrice) * 12
              const yearlyCost = parseFloat(yearlyPrice)
              const savings = (
                ((monthlyCost - yearlyCost) / monthlyCost) *
                100
              ).toFixed(1)

              const creatorData = {
                address: creatorAddress,
                name: creatorName,
                monthlyPrice,
                yearlyPrice,
                subscriberCount,
                isSubscribed,
              }
              allCreators.push(creatorData)

              let subscriptionStatusHtml = ""
              if (isSubscribed) {
                const expirationTime = new Date(
                  subscription[0].toNumber() * 1000
                )
                const isYearly = subscription[2]
                subscriptionStatusHtml = `
                                <div class="subscription-status">
                                    Active Active ${
                                      isYearly ? "Yearly" : "Monthly"
                                    } Subscription
                                    <br>Expires: ${expirationTime.toLocaleDateString()}
                                </div>
                            `
              }

              html += `
                            <div class="creator-browse-card">
                                <div class="creator-header">
                                    <div class="creator-title">${creatorName}</div>
                                    <div class="subscriber-badge">${subscriberCount} subscribers</div>
                                </div>
                                <div style="color: #b8bcc8; font-size: 0.9em; margin-bottom: 10px;">${creatorAddress}</div>
                                
                                <div class="pricing-section">
                                    <div class="price-card">
                                        <div class="price-label">Monthly Plan</div>
                                        <div class="price-amount">${monthlyPrice} STR</div>
                                        <div class="price-period">per month</div>
                                    </div>
                                    <div class="price-card recommended">
                                        <div class="price-label">Yearly Plan</div>
                                        <div class="price-amount">${yearlyPrice} STR</div>
                                        <div class="price-period">per year</div>
                                        <div style="color: #1ce783; font-weight: 600; margin-top: 5px;">
                                            Save ${savings}%
                                        </div>
                                    </div>
                                </div>
                                
                                ${
                                  !isSubscribed
                                    ? `
                                    <div class="subscribe-actions">
                                        <button onclick="selectCreator('${creatorAddress}', false)" class="success">
                                            Subscribe Monthly
                                        </button>
                                        <button onclick="selectCreator('${creatorAddress}', true)" class="success">
                                            Subscribe Yearly
                                        </button>
                                    </div>
                                `
                                    : subscriptionStatusHtml
                                }
                            </div>
                        `
            } catch (error) {
              console.error(`Failed to load creator ${creatorAddress}:`, error)
            }
          }

          if (html) {
            document.getElementById("creatorsList").innerHTML = html
            console.log(
              `Successfully loaded ${allCreators.length} registered creators`
            )
          } else {
            document.getElementById("creatorsList").innerHTML = `
                        <div class="info">
                            <p>No currently registered creators found.</p>
                            <p><strong>Found ${creatorAddresses.length} creator registration events, but none are currently active.</strong></p>
                            <p>Creators may have been registered in the past but are no longer active in the smart contract.</p>
                        </div>
                    `
          }
          creatorsLoaded = true
        } catch (error) {
          console.error("Error loading creators:", error)
          showError(
            "Failed to load creators: " + getErrorMessage(error),
            "creatorsList"
          )

          document.getElementById("creatorsList").innerHTML += `
                    <div style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);">
                        <h4>Debugging Information:</h4>
                        <p><strong>Contract Address:</strong> ${SUBSCRIPTION_ADDRESS}</p>
                        <p><strong>User Account:</strong> ${userAccount}</p>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p><em>Make sure you're connected to the correct network (localhost:8545)</em></p>
                    </div>
                `
        }
      }

      async function refreshCreatorSubscriptionStatus() {
        try {
          if (!userAccount || allCreators.length === 0) return

          console.log(
            "Refreshing subscription status for",
            allCreators.length,
            "creators"
          )

          let html = ""
          for (const creatorData of allCreators) {
            try {
              const [isSubscribed, subscription] = await Promise.all([
                subscriptionContract.isSubscriptionActive(
                  userAccount,
                  creatorData.address
                ),
                subscriptionContract.subscriptions(
                  userAccount,
                  creatorData.address
                ),
              ])

              const monthlyCost = parseFloat(creatorData.monthlyPrice) * 12
              const yearlyCost = parseFloat(creatorData.yearlyPrice)
              const savings = (
                ((monthlyCost - yearlyCost) / monthlyCost) *
                100
              ).toFixed(1)

              let subscriptionStatusHtml = ""
              if (isSubscribed) {
                const expirationTime = new Date(
                  subscription[0].toNumber() * 1000
                )
                const isYearly = subscription[2]
                subscriptionStatusHtml = `
                                <div class="subscription-status">
                                    Active Active ${
                                      isYearly ? "Yearly" : "Monthly"
                                    } Subscription
                                    <br>Expires: ${expirationTime.toLocaleDateString()}
                                </div>
                            `
              }

              html += `
                            <div class="creator-browse-card">
                                <div class="creator-header">
                                    <div class="creator-title">${
                                      creatorData.name
                                    }</div>
                                    <div class="subscriber-badge">${
                                      creatorData.subscriberCount
                                    } subscribers</div>
                                </div>
                                <div style="color: #b8bcc8; font-size: 0.9em; margin-bottom: 10px;">${
                                  creatorData.address
                                }</div>
                                
                                <div class="pricing-section">
                                    <div class="price-card">
                                        <div class="price-label">Monthly Plan</div>
                                        <div class="price-amount">${
                                          creatorData.monthlyPrice
                                        } STR</div>
                                        <div class="price-period">per month</div>
                                    </div>
                                    <div class="price-card recommended">
                                        <div class="price-label">Yearly Plan</div>
                                        <div class="price-amount">${
                                          creatorData.yearlyPrice
                                        } STR</div>
                                        <div class="price-period">per year</div>
                                        <div style="color: #1ce783; font-weight: 600; margin-top: 5px;">
                                            Save ${savings}%
                                        </div>
                                    </div>
                                </div>
                                
                                ${
                                  !isSubscribed
                                    ? `
                                    <div class="subscribe-actions">
                                        <button onclick="selectCreator('${creatorData.address}', false)" class="success">
                                            Subscribe Monthly
                                        </button>
                                        <button onclick="selectCreator('${creatorData.address}', true)" class="success">
                                            Subscribe Yearly
                                        </button>
                                    </div>
                                `
                                    : subscriptionStatusHtml
                                }
                            </div>
                        `
            } catch (error) {
              console.error(
                `Failed to refresh creator ${creatorData.address}:`,
                error
              )
            }
          }

          document.getElementById("creatorsList").innerHTML = html
        } catch (error) {
          console.error("Error refreshing creator subscription status:", error)
        }
      }

      function selectCreator(creatorAddress, isYearly) {
        document.getElementById("subscribeCreatorAddress").value =
          creatorAddress
        document.getElementById("subscriptionType").value = isYearly.toString()

        document.getElementById("subscribeCreatorAddress").scrollIntoView({
          behavior: "smooth",
          block: "center",
        })

        const container = document
          .getElementById("subscribeCreatorAddress")
          .closest(".container")
        container.style.border = "3px solid #007bff"
        setTimeout(() => {
          container.style.border = ""
        }, 2000)

        showInfo(
          `Selected creator for ${
            isYearly ? "yearly" : "monthly"
          } subscription. Click Subscribe below to proceed.`,
          "subscribeResult"
        )
      }

      async function loadCreatorInfo() {
        try {
          const address = document.getElementById("creatorAddress").value.trim()
          if (!ethers.utils.isAddress(address)) {
            throw new Error("Please enter a valid address")
          }

          const creatorInfo = await subscriptionContract.getCreatorInfo(address)

          if (!creatorInfo[0]) {
            document.getElementById("creatorInfo").innerHTML = `
                        <div class="error">Creator not found or not registered</div>
                    `
            return
          }

          const creatorName = creatorInfo[1]
          const monthlyPrice = ethers.utils.formatEther(creatorInfo[2])
          const yearlyPrice = ethers.utils.formatEther(creatorInfo[3])
          const subscriberCount = creatorInfo[5].toString()

          document.getElementById("creatorInfo").innerHTML = `
                    <div class="creator-card">
                        <h3>${creatorName}</h3>
                        <p style="color: #b8bcc8; font-size: 0.9em;">${address}</p>
                        <div class="price-display">
                            <span>Monthly: ${monthlyPrice} STR</span>
                            <span>Yearly: ${yearlyPrice} STR</span>
                        </div>
                        <p><strong>Subscribers:</strong> ${subscriberCount}</p>
                        <button onclick="selectCreator('${address}', false)" class="success">Select for Monthly</button>
                        <button onclick="selectCreator('${address}', true)" class="success">Select for Yearly</button>
                    </div>
                `
        } catch (error) {
          showError(
            "Failed to load creator info: " + getErrorMessage(error),
            "creatorInfo"
          )
        }
      }

      async function subscribeToCreator() {
        try {
          const creatorAddress = document
            .getElementById("subscribeCreatorAddress")
            .value.trim()
          const isYearly =
            document.getElementById("subscriptionType").value === "true"

          if (!ethers.utils.isAddress(creatorAddress)) {
            throw new Error("Please enter a valid creator address")
          }

          const creatorInfo = await subscriptionContract.getCreatorInfo(
            creatorAddress
          )
          if (!creatorInfo[0]) {
            throw new Error("Creator not found or not registered")
          }

          const price = isYearly ? creatorInfo[3] : creatorInfo[2]
          const priceFormatted = ethers.utils.formatEther(price)

          const allowance = await strTokenContract.allowance(
            userAccount,
            SUBSCRIPTION_ADDRESS
          )
          if (allowance.lt(price)) {
            showInfo("Approving STR spending...", "subscribeResult")
            const approveTx = await strTokenContract.approve(
              SUBSCRIPTION_ADDRESS,
              ethers.constants.MaxUint256
            )
            await approveTx.wait()
          }

          showInfo(
            `Subscribing to creator (${priceFormatted} STR)...`,
            "subscribeResult"
          )
          const tx = await subscriptionContract.subscribeToCreator(
            creatorAddress,
            isYearly
          )
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "subscribeResult"
          )

          await tx.wait()
          showSuccess(
            `Successfully subscribed for ${priceFormatted} STR!`,
            "subscribeResult"
          )

          await updateBalances()
          await loadMySubscriptions()

          if (allCreators.length > 0) {
            await loadAllCreators()
          }
        } catch (error) {
          showError(
            "Failed to subscribe: " + getErrorMessage(error),
            "subscribeResult"
          )
        }
      }

      async function loadMySubscriptions() {
        try {
          const subscribedCreators =
            await subscriptionContract.getUserSubscribedCreators(userAccount)
          const subscriptionsList = document.getElementById("subscriptionsList")

          if (subscribedCreators.length === 0) {
            subscriptionsList.innerHTML = "<p>No subscriptions found.</p>"
            return
          }

          let html = ""
          for (const creatorAddress of subscribedCreators) {
            try {
              const [subscription, creatorInfo] = await Promise.all([
                subscriptionContract.subscriptions(userAccount, creatorAddress),
                subscriptionContract.getCreatorInfo(creatorAddress),
              ])

              const expirationTime = new Date(subscription[0].toNumber() * 1000)
              const isActive = subscription[1] && expirationTime > new Date()
              const isYearly = subscription[2]

              const creatorName = creatorInfo[1]
              const monthlyPrice = ethers.utils.formatEther(creatorInfo[2])
              const yearlyPrice = ethers.utils.formatEther(creatorInfo[3])

              html += `
                            <div class="subscription-card ${
                              isActive
                                ? "subscription-active"
                                : "subscription-expired"
                            }">
                                <h3>${creatorName}</h3>
                                <p style="color: #b8bcc8; font-size: 0.9em;">${creatorAddress}</p>
                                <p><strong>Type:</strong> ${
                                  isYearly ? "Yearly" : "Monthly"
                                }</p>
                                <p><strong>Status:</strong> ${
                                  isActive ? "Active Active" : "Expired Expired"
                                }</p>
                                <p><strong>Expires:</strong> ${expirationTime.toLocaleString()}</p>
                                <div class="price-display">
                                    <span>Monthly: ${monthlyPrice} STR</span>
                                    <span>Yearly: ${yearlyPrice} STR</span>
                                </div>
                                ${
                                  !isActive
                                    ? `<button onclick="renewSubscription('${creatorAddress}')" class="success">Renew Subscription</button>`
                                    : ""
                                }
                            </div>
                        `
            } catch (error) {
              console.error(
                `Failed to load subscription for ${creatorAddress}:`,
                error
              )
            }
          }

          subscriptionsList.innerHTML = html
        } catch (error) {
          showError(
            "Failed to load subscriptions: " + getErrorMessage(error),
            "subscriptionsList"
          )
        }
      }

      async function renewSubscription(creatorAddress) {
        document.getElementById("subscribeCreatorAddress").value =
          creatorAddress
        switchTab("subscriber")
        showInfo(
          "Creator address filled. Please select subscription type and click Subscribe.",
          "subscribeResult"
        )
      }

      async function loadMySubscribers() {
        try {
          const subscribers = await subscriptionContract.getCreatorSubscribers(
            userAccount
          )
          const subscribersList = document.getElementById("subscribersList")

          if (subscribers.length === 0) {
            subscribersList.innerHTML = "<p>No subscribers found.</p>"
            return
          }

          let html = ""
          for (const subscriberAddress of subscribers) {
            try {
              const subscription = await subscriptionContract.subscriptions(
                subscriberAddress,
                userAccount
              )
              const expirationTime = new Date(subscription[0].toNumber() * 1000)
              const isActive = subscription[1] && expirationTime > new Date()
              const isYearly = subscription[2]

              html += `
                            <div class="subscription-card ${
                              isActive
                                ? "subscription-active"
                                : "subscription-expired"
                            }">
                                <h4>Subscriber</h4>
                                <p style="color: #b8bcc8; font-size: 0.9em;">${subscriberAddress}</p>
                                <p><strong>Type:</strong> ${
                                  isYearly ? "Yearly" : "Monthly"
                                }</p>
                                <p><strong>Status:</strong> ${
                                  isActive ? "Active Active" : "Expired Expired"
                                }</p>
                                <p><strong>Expires:</strong> ${expirationTime.toLocaleString()}</p>
                            </div>
                        `
            } catch (error) {
              console.error(
                `Failed to load subscription for ${subscriberAddress}:`,
                error
              )
            }
          }

          subscribersList.innerHTML = html
        } catch (error) {
          showError(
            "Failed to load subscribers: " + getErrorMessage(error),
            "subscribersList"
          )
        }
      }

      async function withdrawEarnings() {
        try {
          showInfo("Withdrawing earnings...", "creatorStatus")
          const tx = await subscriptionContract.withdrawCreatorEarnings()
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "creatorStatus"
          )

          await tx.wait()
          showSuccess("Earnings withdrawn successfully!", "creatorStatus")

          await updateBalances()
          await loadCreatorStatus()
        } catch (error) {
          showError(
            "Failed to withdraw earnings: " + getErrorMessage(error),
            "creatorStatus"
          )
        }
      }

      async function stakeSTR() {
        try {
          const amount = document.getElementById("stakeAmount").value
          if (!amount) {
            throw new Error("Please enter amount to stake")
          }

          const amountWei = ethers.utils.parseEther(amount)

          const allowance = await strTokenContract.allowance(
            userAccount,
            SUBSCRIPTION_ADDRESS
          )
          if (allowance.lt(amountWei)) {
            showInfo("Approving STR spending...", "stakingResult")
            const approveTx = await strTokenContract.approve(
              SUBSCRIPTION_ADDRESS,
              ethers.constants.MaxUint256
            )
            await approveTx.wait()
          }

          showInfo("Staking STR...", "stakingResult")
          const tx = await subscriptionContract.stakeSTR(amountWei)
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "stakingResult"
          )

          await tx.wait()
          showSuccess(`Successfully staked ${amount} STR!`, "stakingResult")

          await updateBalances()
          await loadStakingInfo()
          document.getElementById("stakeAmount").value = ""
        } catch (error) {
          showError(
            "Failed to stake STR: " + getErrorMessage(error),
            "stakingResult"
          )
        }
      }

      async function unstakeSTR() {
        try {
          const amount = document.getElementById("unstakeAmount").value
          if (!amount) {
            throw new Error("Please enter amount to unstake")
          }

          const amountWei = ethers.utils.parseEther(amount)

          showInfo("Unstaking STR...", "stakingResult")
          const tx = await subscriptionContract.unstakeSTR(amountWei)
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "stakingResult"
          )

          await tx.wait()
          showSuccess(`Successfully unstaked ${amount} STR!`, "stakingResult")

          await updateBalances()
          await loadStakingInfo()
          document.getElementById("unstakeAmount").value = ""
        } catch (error) {
          showError(
            "Failed to unstake STR: " + getErrorMessage(error),
            "stakingResult"
          )
        }
      }

      async function claimGRNRewards() {
        try {
          showInfo("Claiming GRN rewards...", "stakingResult")
          const tx = await subscriptionContract.claimGRNRewards()
          showInfo(
            "Transaction sent. Waiting for confirmation...",
            "stakingResult"
          )

          await tx.wait()
          showSuccess("GRN rewards claimed successfully!", "stakingResult")

          await updateBalances()
          await loadStakingInfo()
        } catch (error) {
          showError(
            "Failed to claim GRN rewards: " + getErrorMessage(error),
            "stakingResult"
          )
        }
      }

      function switchTab(tabName) {
        document.querySelectorAll(".tab-content").forEach((content) => {
          content.classList.remove("active")
        })

        document.querySelectorAll(".tab").forEach((tab) => {
          tab.classList.remove("active")
        })

        document.getElementById(tabName + "Tab").classList.add("active")

        event.target.classList.add("active")
      }

      function getErrorMessage(error) {
        if (error.message.includes("Already registered")) {
          return "You are already registered as a creator."
        } else if (error.message.includes("Not a registered creator")) {
          return "You are not registered as a creator."
        } else if (error.message.includes("Creator not registered")) {
          return "This creator is not registered on the platform."
        } else if (error.message.includes("Insufficient STR balance")) {
          return "You don't have enough STR tokens."
        } else if (error.message.includes("Insufficient staked amount")) {
          return "You don't have enough staked STR tokens."
        } else if (error.message.includes("No earnings to withdraw")) {
          return "You have no earnings to withdraw."
        } else if (error.message.includes("No rewards to claim")) {
          return "You have no GRN rewards to claim."
        } else if (error.message.includes("Insufficient GRN in reward pool")) {
          return "The reward pool doesn't have enough GRN tokens. Please contact the platform administrator."
        } else if (error.message.includes("user rejected transaction")) {
          return "Transaction was cancelled."
        } else if (error.message.includes("Internal JSON-RPC error")) {
          return "Network error occurred. Please check your connection to the UZH network and ensure you have sufficient UZHETHs for gas fees."
        } else if (error.message.includes("insufficient funds")) {
          return "Insufficient funds for gas fees. Please ensure you have UZHETHs in your wallet."
        } else if (error.message.includes("execution reverted")) {
          return "Transaction failed during execution. Please check the contract requirements."
        } else if (error.message.includes("network changed")) {
          return "Network changed during transaction. Please try again."
        } else if (error.message.includes("Transaction simulation failed")) {
          return error.message + " This usually indicates a network connectivity issue or invalid parameters."
        } else if (error.code === -32603) {
          return "Internal JSON-RPC error. Check network connectivity and gas fees."
        } else if (error.code === -32000) {
          return "Transaction rejected by network. Check gas fees and account balance."
        } else if (error.reason) {
          return error.reason
        } else {
          return error.message
        }
      }

      function showError(message, elementId) {
        const element = document.getElementById(elementId)
        element.innerHTML = `<div class="error">${message}</div>`
      }

      function showSuccess(message, elementId) {
        const element = document.getElementById(elementId)
        element.innerHTML = `<div class="success">${message}</div>`
      }

      function showInfo(message, elementId) {
        const element = document.getElementById(elementId)
        element.innerHTML = `<div class="info">${message}</div>`
      }

      // Mobile menu toggle
      function toggleMobileMenu() {
        const navMenu = document.querySelector('.nav-menu');
        navMenu.classList.toggle('active');
      }

      window.addEventListener("load", async () => {
        // Initialize network UI first
        initializeNetworkUI()

        if (window.ethereum && window.ethereum.selectedAddress) {
          await connectWallet()
        }
      })

      // Close mobile menu when clicking outside
      document.addEventListener('click', (e) => {
        const navMenu = document.querySelector('.nav-menu');
        const toggle = document.querySelector('.mobile-menu-toggle');
        
        if (!navMenu.contains(e.target) && !toggle.contains(e.target)) {
          navMenu.classList.remove('active');
        }
      });
    </script>
  </body>
</html>
